//2020-07-05 노드버드 리뉴얼 강의
 - 지난 노드버드 강의 필기본에다 내용 추가함

//5-1 노드로 서버 구동하기
- npm init
- npm i express : 서버 프레임워크
- npm i axios : hppt 통신
- npm i bcrypt : 비밀번호 암호화
- npm i cookie-parser : 로그인시 쿠키와 세션을 쓸 수 있는데, 쿠키파서필요함
- npm i express-session : express에서 session관리하게 함
- npm i dotenv : 환경변수, 비밀번호 관리
- npm i cors : 백엔트서버와 프론트서버 2개를 만드므로, 서로 주소가 다름
  이렇게 주소가 다르면 보안문제로 제약이 있음, 이 제약을 풀어줌
- npm i helmet hpp : helmet, hpp는 node와 express 보안 담당
- npm i morgan : 서버에 log 남김 ex)누구한테서 요청이 옴, 어떤 응답함
- npm i multer : 이미지 업로드
- npm i multer-s3
- npm i passport passport-local : 회원가입, 로그인 관리
- npm i mysql2 : node와 mysql2와 연결
- npm i sequelize  : ORM -> nodeJS에서 mysql을 사용할 때 
   raw Query문을 사용하지 않고 더욱 쉽게 다룰 수 있도록 도와주는 lib
- npm i -g sequelize-cli
- npm i -D eslint eslint-config-airbnb
- npm i eslint-plugin-jsx-a11y 
- npm i -D nodemon@2 : 서버쪽 코드를 수정하면 항상 재부팅해야 하는데, 
  코드 변화를 감지해서 자동으로 서버를 껐다 켰다 해줌
- swagger : API 설계하는데 도와 준다고 언급만 함 
  https://swagger.io/ 

# 아래는 패스트캠퍼스 쇼핑몰강의 시 받았던 라이브러리 
- npm i connect-flash
- npm i csurf
- npm i express-paginate
- npm i moment : sequelize에서 한국 시간 적용되게 했음
- npm i nunjucks
- npm passport-facebook
- npm i socket.io
- @sendgrid/mail
- @sentry/node
- aws-sdk
- cheerio
- express-recaptcha
- iamporter
- request
- request-promise
- uuid

- nodemon.json 파일 생성
  "watch":[]에 있는 파일들이 수정되면, "exec"을 다시 실행하라=>index.js다시실행
  index.js안에 서버파일이 있으므로, 결국 서버가 다시 실행됨


//5-2 익스프레스로 라우팅하기
- 프론트와 서버의 통신 규약종류 : http api, rest api, GRAPH QL
 rest api는 지키기에 까다롭고 비효율적임, http api로 수업진행
- GET POST PUT(전체수정) PATCH(부분수정) DELETE 메소드
- 웹사이트 접속과 새로고침은 GET주소 요청임
- postman으로 put delete get 등의 요청을 보냄

- app.get : 가져옴
- app.post : 생성
- app.put : 전체 수정, 잘 쓰이지는 않음
- app.delete : 삭제
- app.patch : 부분 수정
- app.options : 찔러보기?
- app.head : 헤더만 가져오기, 잘 안 씀

//5-3 익스프레스 라우터 분리하기

//5-4 Mysql과 sequelize 연결하기 
//5-5 Sequelize 모델만들기
- npm install -g sequelize-auto : auto버전도 나왔음-이번수업에서 사용하진 않음
- npx sequelize init : config, migrations, models, seeders 폴더 생성
- config > config.json : 서버 설정
- "password": "nodejsbook","database": "react-nodebird" 
  => "password":"conkos121","database":reactNodebird로 수정해야 함
- 개발용DB, 테스트용DB, 배포용DB
- models > index.js 파일 원래 적혀있던 코드 수정함
- models 폴더 안의 js파일은 table이라 부름

- sql 개념 설명 (6분쯤)
 - ERD(Entity Relation Diagram) : 테이블들 간의 관계를 정리하는 다이아그램, DB설계시 그려봐야 함
 - Entity Relation Diagram 구글검색하면 사진 많이 나옴


//5-6 Sequelize 관계설정하기
- thebook.id : Node.js 교과서 > 7.6 시퀼라이즈 사용하기 > 7.6.3 관계정의하기
- 리액트를 다루는 기술에서 서버사이드랜더링도 익힐 수 있음
- 유저는 포스트를 생성할때는 일대다관계/포스트에 like달 때는 다대다 관계
- hasMany:일대다관계
- belongsToMany: 다대다관계, 관계중간에 서로의 관계를 정리해주는table이 생성됨
- through: 관계중간에 서로의 관계를 정리해주는 table
- as: 이름이 같을 때, 구분하기 위해사용하는 별칭, 값을 가져올때 as 이름 씀
  ex) db.Post.belongsTo(db.Post, { as: 'Retweet' })
- tip : belongsToMany에는 as를 다 달아줘야 함

//(예전 5-1*) include와 as, foreignKey
- as는 자바스크립트 객체에서 사용하는 이름이고
- foreignKey는 실제 db에서 사용하는 컬럼이름임
- foreignKey명은 as명과 반대로 써야함. 남의 테이블 id를 가리키기 때문
- routes>user에서 아래와 같이적으면, include를 통해 sequ~이 user와 관계있는 테이블들을 자동으로 가져옴
  const fullUser = await db.User.findOne({ 
  where: { id: user.id }, include:[{model:db.post~}{mode.db.user~}]
- fullUser.posts/followings/followers의 배열이 추가되어
- front>components>UserProfile>카드 액션으로 전달됨


//5-7 Sequelize sync와 nodemon, ERD
- npx sequelize db:create => 작동 안함, 테이블만들때는 sql문으로 해야 함 =>database명을 .env에서 불러오지 않고 바로 적으면 작동함2021.04.19
- 데이터베이스생성
  - cmd
   - CREATE DATABASE fastcampus;
   - by안에 본인의 root 패스워드를 입력
    -> 입력을 했는데 비밀번호가 바뀌지 않음
       다른 사이트에서는 use mysql을 한 다음 아래 명령어치라고 함
   - ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';
- ERD 참고 사이트 : DataGrip
  https://www.jetbrains.com/ko-kr/datagrip/

- sequelize 관계 설명하는 웹사이트 : 
  - 생활코딩 mySQL에서 JOIN파트 : mySQL JOIN들으면 이해빠름
  - https://velog.io/@cadenzah/sequelize-document-4
 - User.hasOne(Project)와 같은 메서드를 호출하면, 
   여기서 User 모델(함수를 호출한 모델)이 source 이고 
   Project 모델(함수에 인자로 들어가는 모델)이 target 입니다.
 - Foreign Keys : 관계설정시 생기는 컬럼
  - 모델 정의할 때에 만들어지는 것이 아니라, 두 모델의 연결 관계를 정의 할 때에, 
    연결 관계에 따라 Sequelize가 적절한 모델에 컬럼을 자동으로 만들어줍니다
  - 명명원칙 : target 모델의 이름 + target 모델의 주요 키 이름
  - but as가 사용되면, target 모델이 as 이름으로 대체 => 아래 sequelize 다대다 관계시 생기는 메서드 정리 참조
  - but foreignKey 옵션주면, as 무시하고 target모델 이름이 됨 => 아래 sequelize 다대다 관계시 생기는 메서드 정리 참조
 - Target keys : target모델 컬럼, source 모델 외래 키 컬럼과 연결
 - 1대1 관계 : 하나의 외래 키로 연결된 두 모델 간의 연결 관계
  - BelongsTo : 일대일 관계의 외래키가 source 모델에 존재하는 관계
  - HasOne :  일대일 관계를 위한 외래 키가 target 모델 에 존재하는 관계
 - 1:다 관계 : 단일 source를 복수의 target 모델에 연결, target모델이 key가지는듯
  - target이 복수가 되면 as 옵션이 외래 키 이름에 영향을 주지 않음
 - N:M 관계 : 다수의 source를 다수의 target과 연결,
   서로의 관계를 연결하는 새로운 model이 생기며, 새로생긴 model에
   서로 동등한 자격의 외래 키 projectId와 userId가 생성
  - 재귀관계 : Person.belongsToMany(Person, { as: 'Children', through: 'PersonChildren' })
    자기 참조를 하게 되면 through 테이블에 생기는 2개 외래 키를 
    구분할 수 있어야겠죠? 이때 as 옵션이 사용됨
    한 Person 인스턴스는 personId, Children 별칭의 인스턴스는 ChildId로 구분

- #내생각) as는 1.외래키model명 대체(외래키옵션있으면무효, 일대다관계시 무효)?? 2.post에서 접근할때의 table명칭 


-sequelize 다대다 관계시 생기는 메서드 정리 get,set,add (2020년 5월 22일 추가)
 -일대다관계나 다대다 관계에 있는 table 사이에서, 각 table이 create로 만든 instance들은
  get, count, has, set, add, remove, create의 메서드를 가질 수 있음

 - 아래는 sequelize v4 자료인데, 내용을 직접 요약 
 - https://sequelize.org/v4/manual/tutorial/associations.html#belongs-to-many-associations

 (다대다관계)
 - 다대다관계를 맺는 순간 서로의 관계를 정의하는 새로운 테이블이 생김(through는 필수 옵션)
   
   Project.belongsToMany(User, {through: 'UserProject'});
   User.belongsToMany(Project, {through: 'UserProject'});

   new table UserProject
   projectId   userId
        1         2  
   
  - foreign keys를 지정하지 않으면 자동으로 productId와 userId로 명명됨
  - Project는 getUsers, setUsers, addUser, addUsers 메서드를 가지게되며
    User는 getProjects, setProjects, addProject, addProjects 메서드를 가지게 됨
    user.getProjects => 
  
    User.belongsToMany(Project, { as: 'Tasks', through:  'worker_tasks', foreignKey: 'userId' })
    Project.belongsToMany(User, { as: 'Workers', through: 'worker_tasks', foreignKey: 'projectId' })

    new table worker_tasks
    projectId   userId
        1         2  
  
   - foreign keys를 지정하면 지정한 명칭이 foreign keys가 됨
   # 만약 as를 주고 foreign keys를 지정하지 않으면? TasksId와 WorkersId이 foreignKey가 될듯(아래 재귀 다대다관계 참조)
    new table worker_tasks
    TasksId   WorkersId
        1         2  

   - as(별칭)을 주면, 관계를 맺은 모델에 접근할때 별칭으로 접근할 수 있음
     User에서 Project모델에 접근할때, User.Tasks로 접근 / Project에서는 Project.Workers로 접근

    User.belongsToMany(Project, { as: 'Tasks', through: 'worker_tasks', foreignKey: 'userId', otherKey: 'projectId'}) 

    new table worker_tasks
    projectId   userId
        1         2  
    
    - 다대다 관계에서의 foreign keys는 새로 생성된 through 모델에서의 컬럼명이고, source 모델 key와 연결됨
      otherKey는 target 모델 key와 연결됨
    - Project모델의 별칭: Tasks 
      through 모델의 foreignKey인 userId : source 모델인 user 모델의 key와 연결
      through 모델의 otherKey인 projectId : target 모델인  project 모델의 key와 연결
    => 내가 헤깔렸던부분, 일대다 관계에서 foreignKey는 source 모델key와 연결

    Person.belongsToMany(Person, { as: 'Children', through: 'PersonChildren' })
  
    new table PersonChildren
    PersonId   ChildrenId  => as를 주고 foreign keys를 지정하지 않아서, as명이 foreign key가 됨
        1         2  

    const User = sequelize.define('user', {})
    const Project = sequelize.define('project', {})
    const UserProjects = sequelize.define('userProjects', {
        status: DataTypes.STRING
    })

    User.belongsToMany(Project, { through: UserProjects })
    Project.belongsToMany(User, { through: UserProjects })
    
    - 다대다관계 형성시 생성되는 UserProjects에 컬럼을 추가하려면, 
      관계를 형성하기 전에 동일한 model명으로 define하면 됨
    
    user.addProject(project, { through: { status: 'started' }})   
    - user 인스턴스에 새로운 project인스턴스를 연결하고, UserProjects의 status를 설정할 수 있음

  (Scopes 범위) - 내용 정확하게 이해는 안감
  - 일대다관계 Post --- 여럿 Comments /  Image --- 여럿Comments 
   Post.hasMany(this.Comment, {
    foreignKey: 'commentable_id',
    constraints: false,
    scope: {
      commentable: 'post'
    }
  });
  Comment.belongsTo(this.Post, {
    foreignKey: 'commentable_id',
    constraints: false,
    as: 'post'
  });
  Image.hasMany(this.Comment, {
    foreignKey: 'commentable_id',
    constraints: false,
    scope: {
      commentable: 'image'
    }
  });
  Comment.belongsTo(this.Image, {
    foreignKey: 'commentable_id',
    constraints: false,
    as: 'image'
  });
  
  - 어렵게 설명을 해 놨는데, 요점은 일대다 관계가 맺어지면 
    자동적으로 '다'에 속하는 model의 범위가 특정한 한개의 model로 좁혀진다는 의미인듯
  
  image.getComments() 
  SELECT * FROM comments WHERE commentable_id = 42 AND commentable = 'image';
  => 특정 image(commentable_id = 42 AND commentable = 'image')와 연결된 모든 comments를 comments 모델에서 가져옴

  image.createComment({ title: 'Awesome!' }) 
  INSERT INTO comments (title, commentable_id, commentable) VALUES ('Awesome!', 42, 'image');
  => 특정 image와 특정 comment의 title 값을 comments 모델에서 Awesome!으로 삽입

  image.addComment(comment);
  UPDATE comments SET commentable_id = 42, commentable = 'image'
  => comments 모델에서 commentable_id컬럼 값을 42로, commentable컬럼 값을 image로 설정함
  => 결국, 특정 image와 특정comment를 연결시키게 됨


 - 다대다관계
  Post.belongsToMany(Tag, {
    through: {
      model: ItemTag,
      unique: false,
      scope: {
        taggable: 'post'
      }
    },
    foreignKey: 'taggable_id',
    constraints: false
  });
  Tag.belongsToMany(Post, {
    through: {
      model: ItemTag,
      unique: false
    },
    foreignKey: 'tag_id',
    constraints: false
  });

    new table ItemTag
    taggable_id         tag_id
         1 (Post모델키)    2 (Tag모델 키)

  - 다대다관계에서는 새로생기는 ItemTag 모델에 scope가 존재함
  => ItemTag 모델에서 안에서 서로를 참조하게 된다는 의미인듯

  => 일대다와 다대다관계를 비교해보면,
     일대다관계는 두개의 모델 사이에서 관계가 맺어지는 것이고
     다대다관계는 새로 생성된 through 모델 안에서 서로의 관계가 맺어짐
  
  Post.hasMany(Tag, {
    through: {
      model: ItemTag,
      unique: false,
      scope: {
        taggable: 'post'
      }
    },
    scope: {
      status: 'pending'
    },
    as: 'pendingTags',
    foreignKey: 'taggable_id',
    constraints: false
  });

  new table ItemTag
    taggable_id         tag_id
         1 (Post모델키)    2 (Tag모델 키)

  Post.getPendingTags();

  SELECT `tag`.*  INNER JOIN `item_tags` AS `item_tag`
  ON `tag`.`id` = `item_tag`.`tagId`
    AND `item_tag`.`taggable_id` = 42
    AND `item_tag`.`taggable` = 'post'
  WHERE (`tag`.`status` = 'pending');

  => 다대다관계에서 get메서드를 쓰면, Post.getPendingTags() =>
     tag 모델과 새로생셩된 ItemTag 모델을 INNERJOIN하여 가져오는데,
     ItemTag 모델의 tagId와 tag 모델의 id를 비교해서 같은 데이터들만 
     가져온 후에, 결과적으로 tag 모델의 값들만 가져오게 됨(`tag`.*)
  => 절차가 복잡한데, 결국은 Post와 연결된 모든 tag들을 선택하여 가져오게 됨
  => 과정은 다른데, 결국은 get()메서드는 일대다관계에서나 다대다관계에서나 
     특정 인스턴스와 관련된 모든 데이터를 가져오게 됨
  
  #nodejs 쇼핑몰 코드에서 내용추가
  const status = await user.addLikes(product);//user 인스턴스와 product인스턴스 관계맺음
  //product.dataValues.id만 넣어줘도 정상동작함
  //status에 user인스와 product인스 관계를 알려주는 LikesProducts가 담김 => 외워야 될듯
  //LikesProducts{dataValues:{createdAt:~,updatedAt:~,product_id:2, user_id:3}}

 - #내생각 - add~()에 id가 담길때도 있고 객체가 담길때도 있음, 정확히는 모르겠는데
   new포스트를 new신객체에 연결시 new객체를 인자로 주고, old포스트를 new객체에 연결시, id만 주는듯?
   newPost.addImages(images)/post.addComment(newComment.id)/post.addLiker(req.user.id)


- sequelize.define('User',{})
 - 첫글자 대문자로 쓰면 테이블명은 users로 변경
- npm i mysql2 

- sequelize문법추가(2020-05-21)
  - Difference between Validations and Constraints in sequelize
   - Validations : javascript 레벨 검증 -> 검증 실패시 sql query가 db에 전달 안됨
   - constraints : sql 레벨 검증 -> 검증 실패해도 sql query가 db에 전달되어 실행되고, 
     sql로부터 error 메시지를 전달받음 (SequelizeUniqueConstraintError)
  
// 백엔드 서버 API만들기
# 생활코딩 express 강의 -----------------------------
 - terminal에서 node치면, console창 처럼 사용가능함
 - 라우트 파라미터
  - Route path: /users/:userId/books/:bookId
  - Request URL: http://localhost:3000/users/34/books/8989
  - req.params: { "userId": "34", "bookId": "8989" }
  - app.get('/users/:userId/books/:bookId', (req, res)=>{res.send(req.parpams)})
 - path 모듈 (생활코딩 WEB2 nodejs 'App-입력정보에 대한보안')
  - path.parse('./password.js'); => {root:'',dir:'.',base:'password.js', ext:'.js', name:'password'}
  - 입력받은 주소를 내부 변수로 만들어서 외부에서 data
 - sanitizeHtml (생활코딩 WEB2 nodejs 'App-출력정보에 대한보안')
 - fs.readdir('./data',(err,filelist)=>{}) data폴더의 파일들을 배열로가져와 filelist에 담음
 - fs.rename(oldPath, newPath, callback) : 파일 이름 수정
 - request.on('data',callback)
  - data는 post요청시 받는 모든 데이터 중 처리가능한 양의 조각데이터
 - request.end('data',callback) : 더이상 들어올 data가 없으면 호출
  - qs.parse(body) : 들어온 정보를 객체화 {title:'~',description:'~',...}
 - app.post('/delete_process', (req, res)=>{ res.redirect(path)}
  - res.redirect(path) : 리다이렉트
- 라우터 : app.get(), app.post() 등
- API 다른 서버스가 내 서비스의 기능을 실행할 수 있게 열어둔 창구
- express에서 라우터를 분리하는 방법 제공

- express 미들웨어들 : 미들웨어 안들려다가 다시 들음
 - body-parser : express.urlencoded와 동일
 - compression : 컨텐츠를 압축해서 전송하는 방법
  - npm i compression --save
 - 구분 : application-level, router-level, error-handling, built-in
 - 미들웨어의 실행순서 : next()
  - app.use((req, res, next)=>{로직; next()})
    미들웨어 끝에 next()를 써줘야지 다음 미들웨어 실행됨 
    상위 미들웨어가 하위 미들웨어의 실행을 조절함
- express 정적인 파일 서비스 (이미지, css파일 등)
 - https://unsplash.com/ : 무료 이미지 사이트
 - app.use(express.static('public')); //정적파일지정, public폴더안에서 정적파일찾게함
- express 에러처리
- express router로 파일분리 : express.Router()
- express 보안 : npm i --s helmet, npm i nsp -g (에러나면 sudo 앞에 붙임-nsp check), 
- express generator : 

# express.js 라우트 요청객체(req), 응답객체(res) ----------------------
 - req.params : 이름 붙은 라우트 파라미터를 담는다. 
       ex) app.get(’/:idx’, (req, res) => { res.send(req.params.idx); }); ->    
   req.query : GET 방식으로 넘어오는 쿼리 스트링 파라미터를 담고 있다.
   req.body : POST 방식으로 넘어오는 파라미터를 담고있다. HTTP의 BODY 부분에 담겨져있는데, 
       이 부분을 파싱하기 위해 body-parser와 같은 패키지가 필요하다.
   req.route : 현재 라우트에 관한 정보. 디버깅용.
   req.cookies (req.signedCookies) : 클라이언트가 전달한 쿠키 값을 가진다.
   req.headers : HTTP의 Header 정보를 가지고 있다.
   req.accepts([types]) : 클라이언트가 해당하는 타입을 받을 수 있는지 확인하는 간단한 메서드.
   req.ip : 클라이언트의 IP Address
   req.path : 클라이언트가 요청한 경로. 프로토콜, 호스트, 포트, 쿼리스트링을 제외한 순수 요청 경로다.
   req.host : 요청 호스트 이름을 반환하는 간단한 메서드. 조작될 수 있으므로 보안 목적으로는 사용하면 안된다.
   req.xhr : 요청이 ajax 호출로 시작되었다면 true를 반환하는 프로퍼티
   req.protocol : 현재 요청의 프로토콜 (http, https 등)
   req.secure : 현재 요청이 보안 요청(SSL?) 이면 true를 반환
   req.url (req.originalUrl) : URL 경로와 쿼리 스트링을 반환. 원본 요청을 logging하는 목적으로 많이 쓰임.
   req.acceptedLanguages : 클라이언트가 선호하는 자연어 목록을 반환. 
       header에서 파싱하면 다국어를 지원한는 어플리케이션이라면 초기 언어 선택에 도움을 줄 수 있음.

 - res.status(code) : HTTP 응답 코드를 설정한다. 응답 코드가 redirect(30x)라면 res.redirect를 쓰는게 낫다.
   res.set(name, value) : 응답 헤더를 설정. 일반적으로 직접 쓸 일은 없다.
   res.cookie(name, value, [options]) : 클라이언트에 저장될 쿠키를 설정하거나 제거한다. cookie-parser 패키지가 필요하다.
   res.redirect([status], url) : redirect. 기본 응답 값은 302다.
   res.send(body), res.send(status, body) : 클라이언트에 응답을 보냄. 상태 코드는 옵션. 기본 콘텐츠 타입은 text/html이므로 
       text/plain을 보내려면 res.set(‘Content-Type’, ‘text/plain’)을 먼저 호출 해야한다. 
       JSON을 보낼거면 res.json을 쓰자.
   res.json(json), res.json(status, json) : 클라이언트로 JSON 값을 보냄.
   res.jsonp(json), res.jsonp(status, json) : 클라이언트로 JSONP 값을 보냄.
   res.type(type) : Contents-Type 헤더를 설정할 수 있는 간단한 메서드.
   res.format(object) : Accept 요청에 따라 다른 콘텐츠를 전송할 수 있는 메서드. 잘 안 쓸듯.
   res.attachment([filename]), res.download(path, [filename], [callback]) : 
       클라이언트에게 파일을 표시하지 말고 다운로드 받으라고 전송함. 
       filename을 주면 파일 이름이 명시되며, res.attachment는 헤더만 설정하므로 
       다운로드를 위한 node 코드가 따로 필요핟.
   res.sendFile(path, [options], [callback]) : path의 파일을 읽고 해당 내용을 클라이언트로 전송한다.
   res.links(links) : Links 응답 헤더를 설정한다. 별로 필요 없을 듯.
   res.locals, res.render(view, [locals], callback) : res.locals는 뷰를 렌더링하는 기본 콘텍스트를 포함하는 객체다.
       res.render는 jade와 같은 템플릿 엔진을 사용하여 뷰를 렌더링한다. 뷰 렌더링 세계는 심오하므로 여기서는 자세히 쓰지 않는다.  


//5-8 회원가입 구현하기, 실제 회원가입과 미들웨어들
- db.User.findOne : 1개만 찾아봄
- front에서 post통신로 통신할때, header와 body를 보내는데,
 - body에 데이터가 들어있음 (사용자정보, pass, id 등 )
- status 번호 : 200 성공, 300 리다이렉션, 400 client요청오류, 500 서버오류
- res.json : json객체로 보냄 / res.send : 문자열로 보냄

- front와 back에서 각 termianl을 열어서 서버를 2개 작동시킴, npm run dev
- 미들웨어 : 요청과 응답사이에서 특정 활동 함 ex)morgan, express.urlencoded({}), express.json()
- 코드 똑같이 했는데 회원가입이 안되고 계속 오류 뜸, 원인못찾음

- mySQL도 설치해줘야 함-설치안했더니 계속 오류남
 - 생활코딩 mysql강의에서 설치하는 방법 알려줌
  - google > bitnami wamp(mySQL쉽게 설치하게 도와줌) > on computer win/mac/linux > 
  WAMP 7.2.28-0 다운로드 > 설치, 설치폴더확인 C\Bitnami\wampstack-7.2.28-0
  > root password 설정 > 설치완료되면 bitnami 홈페이지가 뜨면서 Bitnami WAMP Stack 미니창이 뜸
  > Bitnami WAMP Stack > Manage Servers > MySQL Database, Apache Web Server 실행상태로 뜸
  > MySQL Database 켜고 끄는 방법은 C\Bitnami\wampstack-7.2.28-0 > manager-windows 실행
  > MySQL을 command 창에서 실행시켜야 함 > 
  > C:\Bitnami\wampstack-7.2.28-0\mysql\bin> mysql -uroot -p > Enter Password
  > bitnami로 설치시 입력했던 password 입력 > Welcome to the MySQL monitor
- mySQL설치하고, create database reactNodebird하고, back>config>config.js파일에서 password, database 수정
- mySQL worker bench를 실행하려면 visual studio 2019있어야 하는데, 
  지난번에 visual studio 2019 다운받은 후에, 포토샵과 office가 먹통이 되어서 바로 지웠음
  불편하더라도 bench는 추후에 아주 필요시에 사용하기로 함
- front에서 가입하기 누르니깐 이제 됨
- mySQL 명령어(끝에 ; 붙여야함)
 - show databases; use reactNodebird; show tables; select * from users;

- model > user.js  Object.assign()
  const target = { a: 1, b: 2 };
  const source = { b: 4, c: 5 };
  
  const returnedTarget = Object.assign(target, source);
  
  console.log(target); // expected output: Object { a: 1, b: 4, c: 5 }
  console.log(returnedTarget);// expected output: Object { a: 1, b: 4, c: 5 }


//5-9 CORS문제 해결하기
- 브라우저에서 도메인이 다른 서버로 요청을 하면 브라우저 자체에서 차단 함(CORS라고 부름)
- 그런데 프론트 서버와 백엔드 서버주소가 달라도, 요청이 있을때 CORS는 생기지 않음
- 해결방법
 1) Proxy방식 : 브라우저(3060)에서 프론트서버(3060)로 요청을 보낸 후 백엔드서버(3065)로 보냄
    백엔드서버에서 프론트서버로 응답 후 다시 브라우저로 응답
 2) 백엔드서버에서 다음과 같이 설정
   res.setHeader('Access-Control-Allow-Origin', '*') //모든 도메인 허용
   res.setHeader('Access-Control-Allow-Origin', 'http://localhost:3000') //특정도메인 허용
 3) cors 불러와서 사용 npm i cors


//5-10 pasport로 로그인하기, 로그인을 위한 미들웨어들
- source 코드가 해킹당할 경우에 대비해서 .env에 비밀번호를 적어놓고,
  미들웨어 dotenv.config()를 이용해서 비밀번호를 불러오도록 함
- .env는 깃헙에 올리지 않는다
- axios.defaults.baseURL = 'http://loacalhost:3065'; 
 - baseURL로 지정하며 코드작성시 해당 url안적어도 되고, 변경시 일괄 변경가능해짐
- npm i passport, passport-local 


//5-11 쿠키/세션과 전체 로그링 흐름, passport와 쿠키, 세션 동작원리
- 사용자의 로그인 정보는 서버의 세션에 두고, front에는 세션을 조회할 수 있는 쿠키를 전달,
  매번 로그인한 사람 확인하는 작업을 모든 라우터에 붙여줘야 함 -> passport 미들웨어 사용
- 사용자의 모든 정보를 서버쪽에만 두면 메모리가 많이 소모됨
- 미들웨어간에 서로 의존관계가 있는 경우 순서가 중요
- passport.session()는 반드시 expressSession() 다음에 적어야 함
- passport.session()이 expressSession()을 내부적으로 사용하기때문
- passport 아래 index.js : 페이스북, 구글 로그인 등의 다양한 로그인 정보를 취합
- session을 file로 저장해서 눈으로 확인해보려고, session-file-store 설정함
 - npm i -D session-file-store


# 생활코딩 https강의(2013년강의) --------------------------------------------
 - https : Hypertext Transfer Protocol Over Secure Socket Layer
 - https와 ssl : ssl 프로토콜 위에서 https가 실행됨
 - 네트워크 통신의 계층구조
  - application layer : http ftp telnet other
  - SSL/TLS : Handshake change cipher spec alert record
  - transport layer : TCP/IP
 - ssl과 tls : 같은 의미로 받아들이면 됨
 - ssl 디지털 인증서
  - 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서
  - 클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 이 인증서 정보를 전달
  - 클라이언트는 이 인증서 정보가 신뢰할 수 있는 것인지를 검증한 후에 다음 절차를 수행
 - 공개키
  - 공개키 방식은 두개의 키를 갖는데 A키로 암호화를 하면 B키로 복호화를 할 수 있고, B키로
    암호화하면 A키로 복호화할 수 있는 방식(A키는 A키로 복호화불가)
  - private key(개인키,비밀키) : 자신만가짐
  - publick key(공개키) : 타인에게 제공
   - 공개키를 제공받은 타인은 공개키를 이용해서 정보를 암호화함
   - 암호화한 정보를 비공개키를 가진 사람에게 전송
   - 비공개키 소유자가 이 키를 이용해서 암호화된 정보를 복호화

   - 비공개키 소유자는 비공개키를 이용해서 정보를 암호화한 후에 공개키와 함께 정보 전송
   - 정보와 공개키를 받은 사람은 공개키를 이용해서 암호화된 정보를 복호화
   - 정보와 공개키를 획득한 사람은 공개키를 이용해서 암호화된 정보를 복호화 함
   - 이 과정에서 공캐키가 유출된다면 공격자에 의해서 데이터가 복호화될 위험이 있음
   - 그런데도 이렇게 하는 이유는 데이터를 보호하는 목적이 아니라 
     비공개키와 함께 정보를 보낸 사람의 신원보증을 하기 위함
   - 이것을 전자서명이라고 함

 - ssl 인증서
  - 인증서의 기능 
    클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장 (의도했던 서버임을 보장)
    SSL통신에 사용할 공개키를 클라이언트에게 제공
  - CA(certificate authority/root certificate) 
   - 클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장
   - SSL을 통해서 암호화된 통신을 제공하려는 서비스는 CA를 통해 인증서를 구입해야함
  - 인증서 내용
   - 서비스의 정보 : 인증서를 발급한 CA, 서비스의 도메인 등
   - 서버측 공개키 : 공개키의 내용, 공개키의 암호화 방법

  - 인증서 생성방법
   - 서버에서 자신의 회사정보와 공개키를 CA에게 제공
   - CA가 심의한 후 인증서 서버에 발급
   - 서버는 인증서를 클라이언트에게 제공
 
  - CA의 최신 정보를 웹브라우저는 계속 업데이트하고 있음
  
  - ssl인증서가 서비스를 보증하는 방법
   - 클라이언트가 서버에 접속하면 서버는 인증서를 제공
   - 브라우저는 이 인증서를 발급한 CA가 자신이 내장한 CA의 리스트에 있는지 확인
   - CA확인 후 내장된 CA의 공개키를 이용해서 인증서를 복호화함
   - CA의 공개키를 가지고 복호화했다는 의미는 CA가 자신의 비공개키를 통해서 암호화했다는 의미
   - 이는 서버에서 제공한 인증서가 CA에서 발급됐다는 것을 증명 (비공개키는 CA만 발급하므로)
   
  - ssl 방법 : 대칭키와 공개키 방법 혼합
   - 클라이언트와 서버가 주고받는 실제데이터 : 대칭키(공개키보다 컴퓨터자원을 덜 사용)
   - 대칭키의 키 : 공개키
   
   - 전체프로세스
    1) client hello : 클라이언트가 서버에 접속, 이 단계에서 주고받는 정보는 아래와 같음
     -클라이언트 측에서 생성한 랜덤 데이터 : 아래 3번 과정 참조
     -클라이언트가 지원하는 암호화 방식들 : 클라이언트와 서버가 지원하는 암호화 방식이 서로 다를 
      수 있기 때문에 상호간에 어떤 암호화 방식을 사용할 것인지에 대한 협상을 해야 한다. 
      이 협상을 위해서 클라이언트 측에서는 자신이 사용할 수 있는 암호화 방식을 전송한다.
     -세션 아이디 : 이미 SSL 핸드쉐이킹을 했다면 비용과 시간을 절약하기 위해서 
      기존의 세션을 재활용하게 되는데 이 때 사용할 연결에 대한 식별자를 서버 측으로 전송한다.
    
    2) Server Hello : 서버는 Client Hello에 대해 응답 함. 주고 받는 정보는 아래와 같다.
     -서버 측에서 생성한 랜덤 데이터 : 아래 3번 과정 참조
     -서버가 선택한 클라이언트의 암호화 방식 : 클라이언트가 전달한 암호화 방식 중에서 
      서버 쪽에서도 사용할 수 있는 암호화 방식을 선택해서 클라이언트로 전달한다. 이로써 암호화 방식에 
      대한 협상이 종료되고 서버와 클라이언트는 이 암호화 방식을 이용해서 정보를 교환하게 된다.
     -인증서
   
    3) ssl인증서가 서비스를 보증하는 방법단계 진행
     - 클라이언트는 상기 2번을 통해서 받은 서버의 랜덤 데이터와 클라이언트가 생성한 랜덤 데이터를 
       조합해서 pre master secret라는 키를 생성한다. 이 키는 뒤에서 살펴볼 세션 단계에서 
       데이터를 주고 받을 때 암호화하기 위해서 사용될 것이다. 이 때 사용할 암호화 기법은 
       대칭키이기 때문에 pre master secret 값은 제 3자에게 절대로 노출되어서는 안된다.
       
     - 그럼 문제는 이 pre master secret 값을 어떻게 서버에게 전달할 것인가이다. 
       이 때 사용하는 방법이 바로 공개키 방식이다. 서버의 공개키로 pre master secret 값을 암호화해서 
       서버로 전송하면 서버는 자신의 비공개키로 안전하게 복호화 할 수 있다. 그럼 서버의 공개키는 
       어떻게 구할 수 있을까? 서버로부터 받은 인증서 안에 들어있다. 이 서버의 공개키를 이용해서 
       pre master secret 값을 암호화한 후에 서버로 전송하면 안전하게 전송할 수 있다.
     
    4) 서버는 클라이언트가 전송한 pre master secret 값을 자신의 비공개키로 복호화 함
     - 이로서 서버와 클라이언트가 모두 pre master secret 값을 공유하게 되었다. 그리고 서버와 
       클라이언트는 모두 일련의 과정을 거쳐서 pre master secret 값을 master secret 값으로 만든다. 
       master secret는 session key를 생성하는데 이 session key 값을 이용해서 서버와 클라이언트는 
       데이터를 대칭키 방식으로 암호화 한 후에 주고 받는다. 이렇게해서 세션키를 클라이언트와 서버가 
       모두 공유하게 되었다는 점을 기억하자.
    
    5) 세션 : 실제로 서버와 클라이언트가 데이터를 주고 받는 단계
     - 정보를 상대방에게 전송하기 전에 session key 값을 이용해서 대칭키 방식으로 암호화 
       한다는 점이다. 암호화된 정보는 상대방에게 전송될 것이고, 상대방도 세션키 값을 알고 있기 때문에 
       암호를 복호화 할 수 있다.

       그냥 공개키를 사용하면 될 것을 대칭키와 공개키를 조합해서 사용하는 이유는 무엇을까? 
       그것은 공개키 방식이 많은 컴퓨터 파워를 사용하기 때문임
    
    6) 세션종료 : 사용한 대칭키인 세션키 폐기


# 생활코딩 쿠키와 인증 강의 -------------------------------------------------
 - 쿠키 : 접속자의 정보를 front cookie에 저장하고 back서버에 전송하면 쿠키값에 따라서 다른 웹페이지를 보여줌
   서버는 쿠키를 통해 접속자를 식별함 ex)영어/한글 홈페이지, 재로그인 후 동일한 쇼핑몰 장바구니 내역
 - sessionID : 쿠키활용,쿠키중에서 사용자 식별자역할-실제 비밀번호와 이름 등의 내용은 담고 있지않지만 로그인은 가능~헉
   
 - 쿠키생성 : res.writeHead(200, {'Set-Cookie':['yummy_cookie=choco','tasty_cooki=starawberry']})
  - chrome개발창>network>localhost:3000>response header에 set-cookie내용 들어감
  - front서버에 cookie가 저장되고, 추후 특정작업 요청시 front서버에서 cookie를 request header에 넣어서 보냄
  - cookie삭제방법 : chrome개발창>applicaiton>storage>Cookies>금지 아이콘클릭
 - 쿠키읽기
  - npm i -s cookie
  - req.headers.cookie에는 yummy_cookie=choco; tasty_cooki=starawberry 문자열이 들어있음
  - cookie.parse()하면 { yummy_cookie: 'choco', tasty_cooki: 'starawberry' } 객체화시킴
 - 쿠키생존시간설정 : Max-Age(60*60*24*30) 30일동안 생존
  - session cookie : 웹브라우저 끄면 사라짐
  - permanent cookie : 웹브라우저 꺼도 생존
 - Secure & HttpOnly
  - Secure:HTTPS 통신에서만 쿠키를 전송함
  - HttpOnly:자바스크립트로는 쿠키에 접근을 못함
 - path & 도메인
  - path:'Path=/cookie'=> /cookie 포함 하위경로에서만 쿠키보임
  - 도메인:Domain=o2.org => *.o2.org에서만 쿠키보임(하위도메인에서만 보임)

# 생활코딩 세션과 인증 강의 --------------------------------------------------------
 - session은 사용자의 식별에만 cookie를 사용하고, 사용자 실제정보는 back 서버 db에 저장
 - express-session은 request 속성에 request.session를 추가함
  - Session { cookie: { path: '/', _expires: null, originalMaxAge: null, httpOnly: true } }
 -  session store
  - session는 다른 설정없으면 ram에 저장됨 - 컴퓨터껐다켜면 사라짐
  - npm i -s session-file-store => sessions폴더에 파일 저장함
    var FileStore = require('session-file-store')(session);
    session({... store:new FileStore()}))
    => MySQL을 store: 이자리에 넣으면 session저장소가 MySQL이 됨
  - sessions 폴더가 생기고 session 데이터가 들어감
 - session은 app.js에서 app.use(session({ 이 코드에서 생성됨
  -로그인을 안해도 웹사이트에 방문만 해도 발급됨
  -로그인을 하면 session에 passport객체가 생성됨
  -back서버 session 명: Ai2Juklp9dT_omhv8OxUK8RuENpkitvwR
  -web>cookie명 :s%3Ai2Juklp9dT_omhv8OxUK8RuENpkitvwR.rIY3NsWYwIftf1meziokqZsO2lLIaK4fjj6mNW91jzI
  -back서버 session명과 web cookie명의 앞부분이 일치함

 - 전체process
  - 서버에서 사용자식별 쿠키(sessionId=쿠키와동일한듯)를 web에 보내서 저장함
  - web에서 request header cookie에 사용자 식별sessionId(s%3AUuuq5WKmU~)을 서버에 보냄
  - app.use(session())에서 이를 감지하고 sessions 폴더에서 사용자 식별자(Uuuq5WKmUVs~)를 확인
  - app.get('/', (req, res)=>{})의 req.session 객체를 생성함
  - req.session.num==1 과 같이 req.session 객체 내용을 수정하면
  - sessions 폴더에서 해당 사용자식별을 가진 파일 내용이 수정됨
 - session 만료
  - session.destroy((err)=>{ response.redirect(`/`); })
  - logout 누르면 메인페이지로 이동하고, login이 다시 표시됨
  - session 폴더의 해당 사용자 정보를 담았던 식별파일이 삭제되고, 
    새로운 식별파일을 생성한 후 front cookie로 설정함
- session.save(function(){})
 - 메모리에 저장됐던 식별자정보를 파일에 저정한 후에 내부 콜백함수를 호출

- 세션과 쿠키 인증 과정을 단계별로 쉽게 설명한 사이트  
 - 순서는 요약하면 다음과 같습니다.
  1. 사용자가 로그인을 한다.
  2. 서버에서는 계정정보를 읽어 db에서 사용자를 확인한 후, 사용자의 고유한 ID값을 부여하여 세션 저장소에 저장한 후, 이와 연결되는 세션ID를 발행합니다.
  # 사용자가 로그인을 하지않고 단순히 접속해도 세션ID를 부여함, 이후 로그인을 하면 db에서 해당 사용자를 찾은다음 세션ID를 재발급 함
  3. 사용자는 서버에서 해당 세션ID를 받아 쿠키에 저장을 한 후, 인증이 필요한 요청마다 쿠키를 헤더에 실어 보냅니다.
  4. 서버에서는 쿠키를 받아 세션 저장소에서 대조를 한 후 대응되는 정보를 가져옵니다.
  ## 내생각 - 쿠키를 받아 대조할때 쿠키 생성시 설정해둔 secret를 사용하는듯
  5. 인증이 완료되고 서버는 사용자에 맞는 데이터를 보내줍니다.
  https://tansfil.tistory.com/58


# 생활코딩 passport -------------------------------------
 - npm i -s passport
 - npm i -s passport-local : 로컬에서 username과 pwd로 로그인
  - google이나 facebook으로 로그인 하는 다른 전략?(방법)도 있음
 - app.use(passport.initialize()); express에서 passport를 사용하겠다
 - app.use(passport.session()); passport에서 session을 사용하겠다
 - passport.serializeUser(function(user, done){})
  - 로그인성공시 1회 호출, passport.use에서 인증성공시 줬던 authData를 user가 받음
  - session폴더의 식별자파일에 "passport":{"user":"egoing777@gmail.com"} 생성
 - passport.deserializeUser(function(id, done) {}
  - 로그인후 페이지방문마다(쿠키보냄) 호출, 실제데이터를 조회해서 id값 가져옴, 
    생활코딩 예제에서는 "passport":{"user":"egoing777@gmail.com"}에서
    "user"에 담긴 egoing777@gmail.com가 id에 담김
    ## nodebir강의 - 실무에서는 de~결과를 캐싱함:cookie들어올때마다 db에 갔다오면 낭비
 - 전체process -------------------------------------------
  - login요청오면, cookieParser가 내서버에서 보낸 쿠키인지 검정 후,
    (app.use(sesscion({secret에서 넣어준 키와 비교)
    app.post('/auth/login_process)에서 passport.authenticate('local'를 통해 
    passport.use(new LocalStrategy이 호출되어 인증을 시작하고
    ## nodebir강의 삽입
    passport.use(new LocalStrategy의 done(null, user, {reason})이 다시
    passport.authenticate('local', (err, user, info)의 err, uer, info로 전달됨
    req.login(user, fn)을 거치면 쿠키와 session폴더에 식별자파일이 생김
    ## 2020-07-19 nodebird 리뉴얼 강의추가
    passport.serializeUser의 user에 login의 user이 전달되어, req.login과 거의 동시에 실행되고
    user.id만을 이용해서 쿠키를 만듬
    req.login 자동으로 쿠키를 만들어서 헤더에 담아줌 res.setHeader('Cookie','cx~')
    세션은 백서버에 있는 사용자 데이터인데, 전체 사용자데이터를 가지고 있으면 메모리낭비가 심함
    따라서 passport에서는 사용자데이터 중 id만 저장하고 이 id로 쿠키를 구워서 식별에 사용함
    사용자 전체데이터가 필요할때는 id를 가지고 db에 가서 가져옴
    # 정확하지않지만 session()이 호출되어 session폴더안에 식별자파일이 생성된다고 생각됨
    ##
    인증성공시 passport.serializeUser(function(user, done)이 호출되고 
    (1회만 호출)session폴더에 생성된 식별자파일에 passport 속성이 추가됨
    "passport":{"user":"egoing777@gmail.com"}
    이후 successRedirect: '/'에 의해 메인페이지로 이동함
    인증성공후 페이지를 이동할때마다 passport.deserializeUser()가 호출되고
    done(null, authData)2번째 인자가 router.get('/', function(request, 에
    resquest.user로 전달 됨, 이 전달된 resquest.user로 인증을 계속함
    인증이실패하면, session폴더에 식별자파일이 생기지만 passport 속성이 추가되지 않고
    failureRedirect: '/auth/login'에 의해서 로그인페이지로 이동함
 - passport 로그아웃
  - auth.js 파일>router.get('/logout' 에서 아래 2줄을 쓰면됨
    request.logout(); response.redirect(`/`);
    그런데 가끔 logout이 한참후에 진행 될때가 있다고 해서 생활코딩 강사님이 아래코드로 수정
    request.logout();  request.session.save(function(){ response.redirect(`/`); })
 - passport flash message - flash 메세지 1회만 출력
  - passport.use(new LocalStrategy에서 메세지 1회 출력하기(이후 사라짐)
    return done(null, false, { massage:'Incoreect username.' }); 
  - npm i -s connect-flash
  - app.use(flash()):request.flash 객체추가
  - app.get('/flash', function(req, res){ req.flash('msg', 'Flash is back!!')
   - session폴더 식별자파일에 info(첫코드), msg추가 "flash":{"info":["Flash is back!"],"msg":["Flash is back!!"]}}
  - app.get('/flash-display', function(req, res){
    var fmsg = req.flash(); console.log(fmsg); res.send(fmsg); });
   - session폴더 식별자파일에 info, msg삭제 "flash":{"info":["Flash is back!"],"msg":["Flash is back!!"]}}
   - 웹화면에 내용 표시
  - passport.authenticate('local'에서 failureFlash:true 추가
   - 인증실패시, session폴더 식별자파일에 flash:{"error": [Incoreect username.]} 추가됨
   - req.flash('msg', 'Flash is back!!'이 코드가 자동실행되는 셈
  - passport.authenticate('local'에서 successFlash:true 추가
   - 인증성공시,session폴더 식별자파일에 flash:{"success": [welcome]} 추가됨

# 생활코딩 OAuth2 2020.04.21 ----------------------------------------
 - Players
  -Resource Owner : user 
  -Client : 내 서버
  -Resource(데이터서버)/Authorization(인증전용서버) server : 구글, 페이스북, 트위터 등
 
 - Register
  - 내 사이트가 oauth를 사용하려면 구글에 등록을 해야 함
  - Create app 
   - Client ID : 1
   - Client Secret : 123
   - Authorized redirect URIs : https://client/callback => Authorzied code 전달될 주소
 
 - owner의 승인
  - 페이스북에 게시하거나 구글 캘린더를 사용해야 하는 경우 있음
  - owner가 client 사이트에 접속하면 'Login with 페북/구글'  화면 보여줌
  - 'Login with 페북/구글' 클릭하면 아래주소 link 걸음(scope는 사용할 구글서비스)
     https://resource.server?client_id=1&scope=B,C&redirect_uri=https://client/callback
 
  - owner가 login안했으면, login요청
  - owner가 login했으면, client_id와 redirect_uri이용해서 등록된 client 확인
  - owner(user_id 1)에게 B,C 서비스사용 승인요청
  - resource서버는 user_id1 이 scope B,C에 대해서 승인했다고 저장
  
 - resource서버의 승인
  - resource서버는 owner에게 https://client/callbak?code=3형식으로 authorization code(3) 전송
  - owner는 client 서버인 https://client/callbak?code=3으로 이동
  - client가 authorization code 3
  - client는 resource 서버에 아래주소를 통해 authorization code와 client id, secret 전달
   https://resource.server/token?grant_type=authorization_code&code=3
   &redirect_uri=https://client/callback&client_id=1&client_secret=2

 - Access Token 발급
  - resource서버가 client에 Access Token 발급
  - client는 user_id 1에 대해 B,C 서비스 사용 권한을 가짐
 
 - API 호출 : resource서버 작동시키는 코드
 - refresh token : Access Token 수명이 끝났을때, refresh token으로 Access Token을 재발급받음

# 인프런-node교과서 SNS서비스만들기 ---------------------------------
//10장 카카오로그인 
 - sequelize.define(,~ paranoid, ~ ) paranoid:삭제시간 기록?
 - 모델/테이블만들기
 - user 모델 : 카카오등 sns인증을 위해 user모델에 provider와 snsId컬럼생성
   email, nick, password,
   provider:'kakao'
   snsId:profile.id
   
 //10-10 카카오로그인 하기
    passport.use(new KakaoStrategy({
    clientID: process.env.KAKAO_ID,
    callbackURL: '/auth/kakao/callback',
  }, async (accessToken, refreshToken, profile, done) => {
    try {
      const exUser = await User.find({ where: { snsId: profile.id, provider: 'kakao' } });
      if (exUser) {
        done(null, exUser);
      } else {
        const newUser = await User.create({
          email: profile._json && profile._json.kaccount_email,
          nick: profile.displayName,
          snsId: profile.id,
          provider: 'kakao',
        });ㄴ
        done(null, newUser);
      }
    } catch (error) {
      console.error(error);
      done(error);
    }
  }));
};

 - 전체프로세스
  - profile.pug에서 카카오톡 버튼클릭
  - routes> auth.js 라우터에서 이동 아래코드 실행
    router.get('/kakao', passport.authenticate('kakao'));
  - passport>kakaoStrategy 실행
  - 카카오에서 승인 성공시켜주면 router.get('/kakao/callback', passport.authenticate('kakao', 실행
  - 다시 passport>kakaoStrategy 실행
  - 자체 승인하고 최초 로그인 유저면 User 테이블에 추가되며
  - passport> index.js
   - passport.serializeUser : session에 passport객체 추가되어 user.id저장
   - passport.deserializeUser : user.id로 user 찾은다음 req.user에 추가하고
   - 어디서든 req.user로 해당 사용자를 식별하도록 함


# 생활코딩 다중사용자 ------------------------------------
 - npm i -s lowdb : 쉽게 사용할 수 있는 데이터베이스
 - npm run dev 하면 db.json 파일이 생성 => {"users":[]}
 - 웹에서 register버튼 누르면, 가입자 정보가 db.json > {"users":[]} 에 저장됨
 - npm i -s shortid : 겹치지 않는 짧은 id를 생성하게 도와줌 => "id": "qvcVrHow7" 
 - passportjs > operations > Log In, Log Out
  - request.login(user, function (err)
 - npm i -s bcrypt : 비밀번호 암호화

# 생활코딩 login with google on passport -------------------
 - fedrated identity
 - 사용자:google계정하나로 손쉽게 회원가입
 - 서버:고객의 정보를 유지 관리 비용 최소화
 - google:고객 확보, 고객정보수집, lock-in
 - passportjs > provider > google
 - npm i -s passport-google-oauth
 - 전체프로세스
  - 사용자가 권한승인 요청 
  - 구글에서 권한승인코드와 redirect url주소(내 서버주소) 전달
  - 사용자는 내 서버에 접속하면서 권한승인코도 전달
  - 전달받은 권한승인코드와 구글 프로젝트생성시 받았던 Client id와 secret번호를
    내 서버에서 구글로 전달 (passport가 자동으로 해줌)
  - 구글에서 권한승인코드, id, secret번호 확인 후 accessToken발행
  - 내 서버는 accessToken로 구글의 제한된 범위의 서비스 사용할 수 있게 됨
  - accessToken 사용자의 특정 정보를 받은 데이터는 accessToken, refreshToken, profile로 전달됨
    passport.use(new GoogleStrategy({...}, function(accessToken, refreshToken, profile, done) {
    

//(예전)5-12 passport 총정리와 실제 로그인
- front에서 login을 했더니 401에러가 나옴
- chrome개발창>network>login>request payload 에서 post통신때 key가 id로 주어져서 에러났다고 알아냄
  passport를 아래와 같이 지정해놔서 front>components>LoginForm.js에서 dispatch의 data를 userId로 변경해야 함 
  passport.use(new LocalStrategy({ usernameField: 'userId',passwordField: 'password',}
- userId로 고치고 나서는 500번 에러뜸 TypeError: Converting circular structure to JSON
  json문제라서 json을 쓴 passport.authenticate() return res.json(filteredUser);찾고
  const filteredUser = Object.assign({},user)코드에서 user.toJSON()으로 수정
- 로그인 성공
- front>saga>user에서 서버와 통신 성공시, axios부터 로그인된 사용자의 데이터를 result로 받음
  const result = yield call(loginAPI, action.data);
  yield put({ type: LOG_IN_SUCCESS, data:result.data }); //result.data에 사용자의 데이터 들었음
  front>reducer>user에서 LOG_IN_SUCCESS 수정
  me: dummyUser => me:action.data
- TypeError: Cannot read property 'length' of undefined 에러
  UserProfile에서 actions={[<div key="twit">짹짹<br />{me.Post.length}</div>,
  {me.Post.length} length 들어가는 부분 다 지움
- 더미데이터 아닌 사용자 nickname으로 로그인 성공


//5-12 로그인 문제 해결하기

//5-13 미들웨어로 라우터 검사하기
middlewarejs
exports.isLoggedIn = (req, res, next) => {
    if (req.isAuthenticated()) {
      next();
    } else {
      res.status(401).send('로그인이 필요합니다.');//401-로그인관련
    }
  };
  
exports.isNotLoggedIn = (req, res, next) => {
  if (!req.isAuthenticated()) {
    next(); next() 괄호안  인자가 없으면 다음 미들웨어로 감
  } else {
    res.status(401).send('로그인하지 않은 사용자만 접근 가능합니다.');
  }
};

//5-14 게시글,댓글 작성하기 (예전 5-16) 게시글작성과 데이터 관계 연결하기
- db.Hashtag.findOrCreate 없으면 만들고 있으면 아무것도 안함
- back>route>post 코드 너무 어려움 여러번 봐야 할 것 같음
- 정규표현식 exec,match-해당되는 문자열을 배열로반환, hash태그 추출후 배열로 반환
- front>pages>index.js에서 isLoggedIn을 me로 수정 {me && <PostForm/>}
- 코드 수정후 게시물 작성하고 post했는데 오류남
- 한번 불러온 모듈은 node에서 캐싱을 하고 있어서 어디서든 동일한 모듈이 됨
   front>saga>user에서 axios.defaults.baseURL = 'http://localhost:3065/api' 는
   front>saga>post에서도 적용됨 => 파일 잘라서 front>saga>index에 넣음
- 이번에는 db content에 내용이 없이 저장됐음
  front>components>postform 에서 usecallback에서 2번째 인자를 비웠었기 때문, text 적어줌
  onSubmitForm = useCallback(() =>{ dispatch({ type:ADD_POST_REQUEST, data:{ content:text } }) },[text]);


//5-15 credentials로 쿠키 공유하기, 다른 도메인간에 쿠키 주고받기
- 브라우저에서 도메인이 다르면, 요청도 안될 뿐아니라 쿠키도 전송을 하지 못함
  따라서 back 서버에서 접속자가 누구인지 식별을 못하게 됨
  => app.use(cors({//쿠키를 주고 받을 수 있게 함
    //'*'-모든 요청을 받아줌, true-보낸곳의 주소가 자동으로 들어감 'http://localhost:3000'-해당 도메인만 허용
    origin: true, 
    credentials: true,// true로 해야지 쿠키도 전달됨, front axios에서도 설정해줘야 함
  }));

  => saga axois에서도 설정을 함(개별설정)
    function addCommentAPI(data) {
    return axios.post(`/post/${data.postId}/comment`, data, {
      withCredentials:true,
    }); // POST /post/1/comment
}

  => saga>index.js에서 전체 saga에 공통적으로 적용하면, 개별 axios에 적용안해도 됨
     axios.defaults.withCredentials = true;

- chrome개발창>network>login>request payload에서 password 그대로 노출됨
- hppts 적용하면 암호화 됨
- chrome개발창>application>Cookies 쿠키가 없음
- 새로고침을 하면 로그인이 풀림 -> back과 front서버가 도메인이 달라서 오는 문제
- front>saga>user에서 axios의 3번째 인자로 withCredentials주면 쿠키주고받게 됨
  return axios.post('/user/login',loginData, { withCredentials:true, });
  back>index에서 cors에 아래와 같이 인자를 줌
  app.use(cors({ origin: true, credentials: true, }));
- 쿠키 잘 전송됨 그런데 여전히 F5 새로고침하면 로그인 풀림
  쿠키는 있는데 처음 로딩할때 서버에서 사용자데이터를 받는 코드가 없기 때문

//5-16 내 로그인정보 매번 불러오기, 로그아웃과 사용자 정보 가져오기
- saga>user.js logout, loaduser추가
- logout시에는 post통신이라도 data를 주고 받지 않음, 받아놓은 쿠키로 로그아웃
- post통신에서 두번째 인자는 데이터인데 데이터없어도 빈객체는 꼭 넣어야 함
  return axios.post('/user/logout',{}, { withCredentials:true, });
- get통신은 data 보낼게 없어서 두번째 인자에 with~씀
  return axios.get('/user',{ withCredentials:true, });
- loadUserRequest는 사용자가 어느 페이지로 접속할지 모르기때문에 
  공통 레이아웃인 _app.js 나 AppLayout.js 에 작성함
- AppLayout.js에서 {/* isLoggedIn에서 me로 수정 */}
  <Row gutter={20}> <Col xs={24} md={6}> {me ? <UserProfile/> : <LoginForm/>}
- reducer>user에서 isLoggedIn 다 지움 why? me와 중복됨
- 이제 로그인 후 F5로 새로고침해도 로그아웃 안됨
- back 서버를 껐다 켜면, 서버 컴퓨터 메모리에 있던 session과 cookie가
  휘발되기 때문에, 로그인 된 사용자들은 다 로그아웃됨
  그런데 실제에서는 그렇지 않음 session를 모아두는 db(redis)를 따로 두기 때문


//5-17 게시글 불러오기, 
- limit과 offset 방식은 실무에서 잘 안쓰인다고 함, 게시물을 삭제하거나 추가하면, 불러오는 
  게시물들이 꼬이게 됨 ex) 20~1까지 불러왔는데, 중간에 21게시물이 생기면 11~2까지의 게시글을 불러오게 됨
- 따라서 임의로 lastId를 줘서 10개씩 게시물을 가져오게 코딩함  

- 새로고침 할 때마다 게시글들 가져와야 함 / routes>posts 수정
- db.Post.findAll({}) 모든 게시글 가져옴
- 어느 때에 tojson()해줘야 하나? 기본적으로는 tojson()안해도됨
 - db에서 가져온 객체를 변형할때 붙임
   const user = Object.assign({}, req.user.toJSON());
   delete user.password;
- front>saga, reducer>post 수정
- 로그인을 하지 않아도 게시글을 볼수 있는 경우 withCredentials 안넣어도 됨
- front>pages>index 수정
- 새로고침 할때마다 load user, load posts 둘 다 함
- post.user 작성자 정보 없어서 오류남
- back>routes>posts에서 include 해줌
  await db.Post.findAll({//모든 게시글 가져옴
    include: [{
      model: db.User,
      attributes: ['id', 'nickname'],
    }],
    order: [['createdAt', 'DESC']], // DESC는 내림차순, ASC는 오름차순
  });

- font>components>postform  text.trim() //공백제거
- 정규표현식 테스트 사이트 : https://regexr.com/
  \s는 여백을 의미, []안에서의 캐럿은 [^] not을 의미
  /#[^\s]/g #과 여백이아닌 문자 // #[^\s]+/g #과 다음 여백이 나올때까지


# 생활코딩 정규표현식 ------------------------------------
 - zvon.org 사이트에서 나오는 내용으로 강의
 - 대소문자 구분, 띄워쓰기 인식
 - 정규표현식 exec,match(문자열) 해당되는 문자열을 배열로반환, hash태그 추출후 배열로 반환
 - ^(캐럿) : /^who/g - who를 찾되 제일 처음에 있는 who만 찾음 
 - $ : /who$/g - 제일 나중에 있는 who만 찾음 
   who is who - 앞 who만 찾음 // 뒤 who만 찾음
 - \ (백스페이스/이스케이핑): 단순문자처리 - \$ 단순 문자 $
 - . (점): 모든 문자, 공백, 특수문자를 가리킴(무슨 문자인지 모를때 사용)
  ...... -> 모든 6자리 문자
 - [] : [oyu] -> o y u 각 문자를 찾음 // [dH]. -> 2문자를 의미, d나 H와 아무문자로 된 2문자를 찾음
 - [-] : 범위를 나타냄 - [C-F] -> CDEF까지 // [C-Ea-c2-5] -> CDE abc 2345 각 문자를 찾음
 - [^] : not - [^Cgi5] -> C g i 5 이들 문자가 아닌 것들을 찾음
 - (|) : subpattern - (on|use|idea) -> on use idea 뭉쳐진 단어들을 찾음 // 공통되는부분에 사용
   (Mon|Tues|Fri)day -> Monday Tuesday Friday 단어를 찾음
 
 - 수량자(중요함)
  - * : 앞 문자가 0개이상 - a*b -> aab ab bc 등을 찾음
  - + : 앞 문자가 1개이상 - a+b -> aab ab
  - ? : 앞 문자가 1개이하 - a?b 
  - {} : .{5} -> 어느문자든 5글자(공백포함) One r~
  ex) .* : 모든 문자 / -A*- : -- -A- -AA- / 
      [-@]* : -- -@-  없어도 된다고 공백을 찾으라는 것은 아님, 없으면 안 찾음, 근데 [-@]와 똑같은거 같은데?
      \*+ : * ** *** / -@+- : -@- -@@- / 
      [^ ]+  (캐럿+공백) : 공백아닌 문자
      X?XX?X : -XX
      [els]{1,3} : e l s가 1번이상 3번이하로 나오는 문자 찾음 ess ll ell 
      [a-z]{3,} : a~z가 3번이상 -> 3글자이상 aaa abc ring bind 
      r.* : r로시작하는 모든 문자(공백포함)
      r.*? : *와 ?같이쓰면 *가 앞문자를 0개 가지게 됨 -> r 한 문자만 찾음
      r.+? : +와 ?같이쓰면 +가 앞문자를 1개 가지게 됨 -> ri r과 한문자 조합
      r.?? : ?와 ?같이쓰면 ?가 앞문자를 0개 가지게 됨
      => 위 3가지 경우, 수량자 뒤에 ?가 붙으면 수량자 앞글자의 허용범위가 가장 작은 1개로 축소됨
      <div>.+</div> => '<div>text</div><div>test</div><div>t</div>' 전체가 선택됨
      <div>.+?</div> => '<div>text</div>''<div>test</div>''<div>t</div>' 태그단위로 선택됨 이유는 잘 모르겠음
      태그 없으면 . 와 .+? 는 결과가 같음

 - \w (word): 알파벳+숫자+_ 의 조합(공백, 특수문자불포함) -> A1 B1 c3 d_4 e 5 ffgg
  [a-z]\w* -> c3 d_4 A1(안됨X)
 - \W : word가 아니다-공백, 특수문자
 - \s (white space): 공백
 - \S : not white space
 - \d (digit) : 숫자만선택 -> 12 123 112 
 - \D : not digit 문자,특수문자만선택
 - \b (boundary) : 앞이나 뒷부분 선택 \b\w -> 앞문자 강조 / \w\b -> 뒷문자강조 / \b\w+\b -> 단어강조
 - \B : not boundary
 - \A : 기본적으로 ^과 같지만, 여러 줄에서도 한 줄에서만 해당 첫 단어를 찾음
      ^은 여러줄 중 각 줄에서 해당 첫 단어를 찾음
 - \Z : 기본적으로 $와 같지만, 여러 줄에서도 한 줄에서만 해당 마지막 단어를 찾음

  정규표현식 쉽게 설명한 사이트
  var objectInitializer = new RegExp('정규표현식',['Flag']);  
  var regExp = /정규표현식/[Flag];
  만약 Flag를 설정 하지 않을 경우에는 문자열 내에서 검색대상이 많더라도 
  한번만 찾고 끝나게 됩니다.
   Flag
   g : Global - 문자열 내의 모든패턴을 찾습니다
   i : Ignore Case - 문자열의 대소문자를 구별하지 않습니다. 
   m : Multi Line 문자열의 행이 바뀌어도 찾습니다
  http://www.nextree.co.kr/p4327/


//5-18 게시글 좋아요
- addLikers, removeLikers 매서드 사용

(예전6-14) 게시글 좋아요, 좋아요취소
- components>PostCard> HeartOutlined 아이콘 눌렀을때 효과 줌
 <HeartOutlined key="heart" onClick={onToggleLike}/>
- saga>post 수정 likePost, unlikePost
- routes>postjs 수정
 - 아래처럼 관계설정하는 거 아직 잘 모르겠음
 - db.Post.belongsToMany(db.User, { through: 'Like', as: 'Likers' });
 - post.addLikers(req.user.id) 
- reducer>postjh 수정

- 좋아요 눌렀는데 오류 남
- reducer에서 const Likers = [{ id: action.data.userId }, ...post.Likers]
  ...post.Likers에 값이 없어서 오류난 것임
- route>posts, user js에서 Likers를 넣어줘야 함
- postsjs를 언제썼는지 까먹음   
  index.js에서 LOAD_MAIN_POSTS_REQUEST액션으로 axios.get('/posts') 통신할때 사용
 - posts, user js 아래코드 추가해줌
  {
    model: db.User,//게시글에 좋아요 누른 사용자
    through: 'Like',
    as: 'Likers',
    attributes: ['id'],
  },

- 나는 그래도 오류남 post.addLiker is not a function
 routes>postjs>router.post('/:id/like~)에서 await을 빼서 오류났음
 const post = db.Post.findOne({ where:{id:req.params.id} })
 await 붙이니 성공

- 좋아요를 누르면 빨간색으로 표시되도록 해서 시각적으로 알아차리게 함
- Postcardjs>Card>HeartOutlined 
- ant 적는 방법이 달라져서 강의대로 하면 안됨,
- 아래처럼 수정하면 됨
liked
?<HeartTwoTone key="heart" twoToneColor="#eb2f96" onClick={onToggleLike}/>
:<HeartOutlined key="heart" onClick={onToggleLike}/>,


(예전 6-18) 다른 리듀서 데이터 조작하기
- comnponent>userprofile>card 짹짹 숫자가 안올라 가고 새로고침해야지 올라감
 <div key="twit">짹짹<br />{me.Posts.length}</div>
- 짹짹은 state.user.me.posts 배열의 갯수 length로 코딩 됨
- redux의 단점은 post reducer는 post reducer애서만 데이터 조작가능하고, 
  user reducer는 user reducer안에서만 조작가능하다는 것
- me.Posts.length은 user reducer에 있는데, add post success 액션은 
  post reducer에서 관리됨
- user reducer에 있는 액션을 saga에서 호출하게 끔 해야 함
- saga>post>addPost은 post reducer에 속한 액션을 처리함 
  아래코드 처럼 ADD_POST_TO_ME 액션만들어 추가함
  import { ADD_POST_TO_ME } from '../reducers/user';
  
  function* addPost(action) {
    try {
       yield put({ // user reducer의 데이터를 수정
        type: ADD_POST_TO_ME,
        data: result.data.id,

- reducer>user ADD_POST_TO_ME 추가


//5-19 게시글제거/닉네임변경
- 테이블 삭제: User.destory({})
- 테이블 수정: User.update({},{조건})

(예전6-20) 닉네임 수정하기
- sequelize 수정해보기
- component>nicknameEditForm 수정
- saga>user EDIT_NICKNAME_REQUEST~ 추가
- patch 부분수정 : user 중 nickname만 수정함
  return axios.patch('/user/nickname', { nickname },
- route>user 
  await db.User.update({
    nickname: req.body.nickname,
  }, {
    where: { id: req.user.id },
  });
  res.send(req.body.nickname);

- reducer>user EDIT_NICKNAME_REQUEST~ 추가
- userProfile에서 Card>Card.Meta>avatar의 nickname도 같이 수정됨
<Card.Meta avatar={<Avatar>{me.nickname[0]}</Avatar>} title={me.nickname} />
- nickname이 들어있는 다른 것들도 일괄 수정됨

//5-20 팔로우/언팔로우
- get메서드 사용
- const followings = await user.getFollowings();
(예전6-17) 팔로우, 언팔로우
- postcard>card>extra>button 팔로우 누르면 팔로우
- saga>userjs 수정
- routes>userjs router 만듬
- reducer>userjs 수정


//5-21 이미지 업로드를 위한 multer 
- app에 multer를 적기 보다 각 라우터마다 multer 세팅을 달리해서 적음
 - 각 라우터마다 1개 이미지 혹은 여러 이미지 혹은 텍스트만 받을 수 있기 때문
- uploads파일 생성 / fs.accessSync('uploads), fs.mkdirSync('uploads)
(예전6-8) 이미지업로드 프론트 구현하기
- components>postform
 - const imageInput = useRef();, imageInput.current.click();

-form태그의 enctype 
 - form data가 서버로 제출될 때 해당 데이터가 인코딩되는 방법을 명시
 - method 속성값이 “post”인 경우에만 사용
 - application/x-www-form-urlencoded : 기본값으로, 모든 문자들은 서버로 보내기 전에 URL-Encode됨.
 - multipart/form-data : 모든 문자를 인코딩하지 않음을 명시함.
   이 방식은 form요소가 파일이나 이미지, 비디오를 서버로 전송할 때 주로 사용함.
 - text/plain : 공백 문자(space)는 "+" 기호로 변환하지만, 나머지 문자는 인코딩되지않고 문자상태로 전송.
- 브라우저에서 제공하는 formdata 객체(파일담는객체)에 key/value쌍을 추가함
- formData.append(name, value); formData객체의 기존 키에 새 값을 추가하거나 키가 없는 경우 키를 추가
- 원래 form데이터는 submit을 하면 자동으로 formdata를 생성해서 통신하는데, 
- 여기서는 직접 formdata를 만들어서 ajax통신 함
- 이미지 업로드 방법
 - 전통적으로는 이미지와 게시글이랑 같이 보냈음
  - 그런데 실제 서비스를 진행해 보면, 같이 보내면 단점이 여럿 있는데 
  - 업로드 시간이 지연되는 단점이 큼
  - 이를 해결하려고 이미지는 미리 업로드 해 놓고 게시글은 따로 업로드함

(예전6-9) multer로 이미지 업로드 받기
- front에서 보내온 formdata는 bodyparser로 처리가 안됨, multer 미들웨어를 사용함
- routes>postjs
- multer 설명 한국어 사이트
 - multer는 body와 한개 혹은 여러개의 file객체를 request에 추가함 
   ex) upload.single('avatar') - req.file객체={fieldname:'avatar', originalname:~,filename:'~',path:''}
       upload.array('photos',12) - req.files객체=photos:[file0,file1~]?
       upload.fields([{name:'avatar',maxCoutn:1},{name:'gallery',maxCount:8}]) - req.files객체 [{avatar:~},{gallery:~}]
       array vs fields 
       arrary(한개 input, 한개name, 여러사진) : input name="user_files" =>  user_files:[file_info0,file_info1,file_info0]
       fields(여러 input, 여러name, 여러사진) : input name="user_profile_file" / input name="user_title_file"
       => [{user_profile_file:~}, {user_title_file:~}]
       upload.none : 이미지나 파일을 하나도 안 올린 경우
       req.body - 텍스트필드

https://jamong-icetea.tistory.com/133
  - 이미지를 3개 올렸을때
  - req.files = [
  {
    fieldname: 'image',
    originalname: '2019-01-02 쇼챔피언 (1).jpg',
    encoding: '7bit',
    mimetype: 'image/jpeg',
    destination: 'uploads',
    filename: '2019-01-02 쇼챔피언 (1)1587225002565.jpg',
    path: 'uploads\\2019-01-02 쇼챔피언 (1)1587225002565.jpg',
    size: 188287
  },
  {
    fieldname: 'image',
    originalname: '2019-01-02 쇼챔피언 (5).jpg',
    encoding: '7bit',
    mimetype: 'image/jpeg',
    destination: 'uploads',
    filename: '2019-01-02 쇼챔피언 (5)1587225002568.jpg',
    path: 'uploads\\2019-01-02 쇼챔피언 (5)1587225002568.jpg',
    size: 184312
  },
  {
    fieldname: 'image',
    originalname: '2019-01-09 쇼챔피언 (1).jpg',
    encoding: '7bit',
    mimetype: 'image/jpeg',
    destination: 'uploads',
    filename: '2019-01-09 쇼챔피언 (1)1587225002569.jpg',
    path: 'uploads\\2019-01-09 쇼챔피언 (1)1587225002569.jpg',
    size: 182847
  }
]

(예전6-11) 폼데이터로 게시글 올리기(원래텍스트 게시글은 req.body로 올라감)
- components>postformjs>onSubmitForm 수정
- upload.none 사용해봄
 - front>formData.append('image', i);에서 image에는 text인 이미지주소가 담겼음
 - 따라서 req.body에 담김
- routes>hashtag, post, posts, user에서 db불러올때, db.Image도 같이 불러오게 코드수정
- reducer>post>case ADD_POST_SUCCESS 에서 imagePaths: [] 해줘야 
  업로드 후 미리보기 이미지들 없어짐


(예전6-12) 게시글 이미지 표시하기
- components>postCard>card부분을 아래와 같이작성 -> src에 이미지주소가 뜨고 이미지 미리보기 됨
- back에서 받아오는 fullPost에서 이미지주소는 Images : [[image], [image]]로 들어있음
 cover={post.img && <img alt="example" src={post.img}></img>}
 cover={post.Images[0] && <img alt="example" src={`http://localhost:3065/${post.Images[0].src}`}></img>} 
 - 그런데 여러장의 이미지가 표시가 안되고 한장만 표시됨
- components>postImages js 작성해서 postCard에 연결해줌
 - 1장이면 100%, 2장이면 50%, 2장이상이면 1장 +더보기


//5-22 express.static
(예전6-10) express.static과 이미지 제거
- back 서버측 이미지를 가져오지 못하고 있는데, 미들웨어로 해결가능
- back>indexjs app.use('/',express.static(path.join(__dirname,'uploads'))) 
 - uploads폴더의 파일은 다른 서버에서 자유롭게 가져갈수있게 함
 -'/'는 uploads폴더를 root 폴더인것처럼 사용할 수 있게 함(front에서 /img-cj~.png로 접근가능)
 - 나는 사진을 못불러옴. 이유 못찾음 => postform에서 img src 주소 수정해봄 
  local:3000 ->3065 => 미리보기 됨
  img src={`http://local:3060/${v}`} style={{ width: "200px" }} alt={v}

 - components>postformjs 수정
 - REMOVE_IMAGE 액션은 saga 거치지 않고 reducer에서 filter함수 이용해서 제거

//5-23 해시태그 등록하기
(예전6-1) 해시태그 링크로 만들기
- 해시태그를 클릭할 수 있게 하는 방법이 자바스크립트에서는 좀 힘듬
- 문자열 해시태그를 next의 Link태그로 전환 (a tag 아님)  
  components > postcard > Card > Card.Meta > description 
- 정규표현식으로 문자열을 분해할 수 있음 : 문자열.split(정규표현식)
  split(/#[^\s]+/g) : 해시태그만 빼고 분해
  split(/(#[^\s]+)/g) : 해시태그포함해서 분해
  이유는 모르겠는데 괄호안에 정규표현식을 넣으면 자기 자신도 포함해서 분해가 됨
  => 그냥 외워야 되나?
  [,ab,ab].split(","") =>["","ab","ab"] 
  나누는 기준이 되는 것이 첫문자에 나오면 배열의 첫원소는 ""가 됨(앞에 아무것도 없으니깐)
- hashtag 페이지 만듬
- next는 동적주소를 처리하지 못함(쿼리스트링으로 하면 할 수 있긴 함)
 - 그래서 front에도 동적인 처리는 할 수 있도록 express를 연결함


//5-24 리트윗하기
- 리트윗 프론트 만들때, postcard.js에서 userEffect를 만들면, 지속적으로 리랜더링 됨
 => 이유는 8개의 PostCard에서 모두 리랜더링이 일어나기 때문
    지속적으로 리랜더링이 되는 것임
 => 해결방법 : 상위 콤포넌트에 적음 => pages>index.js로 해당 코드 옮김
 function PostCard({post}) {
  useEffect(()=>{
      if(retweetError){
        alert(retweetError);
      }
    },[retweetError]);
 }


(예전6-15) 리트윗 API 만들기
- post 테이블 : 20번째 포스트는 2번째 포스트를 리트윗한것이라는 의미
 id  content createdAt updatedAt UserId RetweetId
 20    a                            3       2
   
- postcard>card>RetweetOutlined의 onClick에 onRetweet 함수 연결
- saga>postjs 작성
- routes>postjs retweet 라우터 작성 
 - 리트윗 게시글을 찾아서 불러오는데 테이블간 관계가 너무 복잡함, 아래는 관계도 그림

  Post:post 테이블
  id content userId RetweetId
  4(v)         2       1       => retweet.id를 post.id와 비교 후 선택
 
  User:user 테이블 
  id  nickname
  2(v)           => user.id와 비교후 선택
 
  Retweet:post 테이블
  id content userId RetweetId
  4         2         1(v)
  1(v)                 3         =>  RetweetId와 post.id 비교후 선택
 
  User:user 테이블 
  id  nickname
  3(v)           => user.id와 비교후 선택
 
  Image:image 테이블
  id src PostId
          10(v)  => PostId와 비교후 선택

- 강사님 코드오류로 에러남, saga>post>retweetAPI에서 빈 객체를 넣어줘야 하는데 빼먹음
  return axios.post(`/post/${postId}/retweet`, {}, {
  withCredentials: true,
});
- catch (e) => e객체에 많은 정보가 들어있는데, 로그인 해달라고 하는 문구가
  들어있는 곳은 e.response.data임 -> alert 해줌


(예전6-16) 리트윗 프론트 화면 만들기
-postCard>card> card를 구별하기 위해 postcardcontent js 만들고 description 내용을 옮겨적음
-routes>postsjs, hashtagjs 에서도 아래코드 추가
{
  model: db.Post,
  as: 'Retweet',
  include: [{
    model: db.User,
    attributes: ['id', 'nickname'],
  }, {
    model: db.Image,
  }


//5-25 퀘리스트링과 lastId방식
- front>saga>post 
 function loadPostsAPI(lastId) {
  //get방식은 data를 넣어줄 수 없어서 query방법으로 data줌
  return axios.get(`/posts?lastId=${lastId || 0}`);
}

-back>posts.js
 router.get('/', async (req, res, next) => { // GET /posts
  try {
    const where = {};
    if (parseInt(req.query.lastId, 10)) { // 초기 로딩이 아닐 때
      //sequelize 조건문 where{id:[Op.lt]: parseInt(req.query.lastId, 10)}
      where.id = { [Op.lt]: parseInt(req.query.lastId, 10)}
     
- 끝 게시물부터 첫번째 게시물까지 불러오나서, 6번게시물에서 1번게시물을 여러번 불러옴
=> reducer>post.js에서
    case LOAD_POSTS_SUCCESS:
      draft.loadPostsLoading = false;
      draft.loadPostsDone = true;
      draft.mainPosts = draft.mainPosts.concat(action.data);
      draft.hasMorePosts = action.data.length === 10; //10개보다 작으면 마지막 게시글인걸로 함,
      => hasMorePosts가 false로 변함 => 더이상 불러오지 않음


//6장 Next.js 서버사이드랜더링 
(예전7-1) 서버사이드랜더링
- 로그인을 한 후에 새로고침을 하면 잠시동안 로그인이 풀림
- 검색엔진에 노출되지 않음
- 검색엔진은 봇이 돌아다님, 링크 타고 돌아다니면서 데이터를 가져옴
- SPA같은 경우, 처음에는 빈페이지가 로딩되고 이후에 데이터를 불러오는데,
  검색엔진 봇은 로딩후 데이터를 불러오는데까지 기다리지 않고, 빈페이지를 읽음
  따라서, back 서버에서 front에 먼저 데이터를 넣어줘서 랜더링하게 해야 함
- 포스트맨 다운로드 후, get방식 localhost:3060 주소로 통신하면
  head와 body 일부 내용만 있고 대부분의 내용은 빈채로 reponse됨
- 넥스트를 쓰는 가장 큰 이유가 서버사이드랜더링 때문
- getInitialProps는 front client(웹브라우저)와 front server에서 다 실행됨
- front server 에서는 처음 페이지를 로딩할 때 실행됨, 이후 front client에서는 
  next로 페이지 오갈때 실행됨
- pages>index에서 아래와 같이 수정
  Home.getInitialProps = async(context) =>{
    context.store.dispatch({
      type:LOAD_MAIN_POSTS_REQUEST
    })
  }
- 그런데 오히려 post들이 사라져버림 -> _app js에서 saga 설정을 해줘야 함
- npm i next-redux-saga : next용 리덕스사가, 
  넥스트 서버에서 리덕스사가를 사용할수 있게 함
  import withReduxSaga from 'next-redux-saga' 
  store.sagaTask = sagaMiddleware.run(rootSaga);
  export default withRedux(configureStore)(withReduxSaga(NodeBird));
- postman에서 보는 화면이 검색엔진이 보는 화면
- 이제 새로고침을 하면 게시글은 먼저 채워져 있음, 로그인창은 여전히 중간에 풀림
  postman에서 localhost:3060치면 게시글들이 채워져 있음
- index.js에 getInitialProps를 넣지 않았을때, _app에서의 context에는
  getInitialProps없었는데 작성후 추가됐음
Component: [Function: Home] { getInitialProps: [AsyncFunction] },

//6-1 서버사이드랜더링 준비하기 2021-04-28
-getServerSideProps는 front서버에서만 실행됨
-front > _app.js
import withReduxSaga from 'next-redux-saga'; //더이상 필요없어짐
export default wrapper.withRedux(App);

-package.json에서도 next-redux-saga 지움

-next 8버전에서는 getInitialProps로 서버에서 데이터를 받았는데, 조만간 없어질수 있다 함
-next 홈페이지에 들어가면 잘 설명되어져 있음, 여기서는 redux와 saga를 사용해서 코드가 복잡함
 *getServerSideProps는 객체를 return 해야하는데, reducer>index.js에서 return을 함
-redux INIT초기상태-> getServerSideProps실행 dispatch -> __NEXT_REDUX_WRAPPER_HYDRATE실행
 
#순서-----------------------------------------------------------------
 0) reducer>index.js => rootReducer default 실행되면서 user, post상태 초기화
    const rootReducer = (state, action) =>{ 
    default:{ const combineReducer = combineReducers({ user, post, });
 1) pages>index.js getServerSideProps
    context.store.dispatch({ type:LOAD_USER_REQUEST,}) => const rootReducer = (state, action)
    => sagas > user.js > loadUser 실행
 2) context.store.dispatch({ type:LOAD_POSTS_REQUEST,=> const rootReducer = (state, action)
    => sagas > post.js > loadPosts 실행
 3) context.store.dispatch(END);=> const rootReducer = (state, action)
 4) await context.store.sagaTask.toPromise(); => const rootReducer = (state, action)
 5) dispatch 후의 user(me), post(mainposts)에 데이터가 채워짐
 6) pages>_app.js => redex실행되면서 reducer에서의 initialState의 user(me), post(mainposts)가 채워짐
    wrapper.withRedux(App);
 7) const rootReducer = (state, action) =>{
    case HYDRATE: return action.payload;
 8) 이 다음단계는 뭐지?

#순서-----------------------------------------------------------------

-front>page>index.js getServerSideProps가 먼저 실행
//const Home = () =>{} 보다 먼저실행
export const getServerSideProps = wrapper.getServerSideProps(async(context)=>{
    console.log('Home context', context);
    context.store.dispatch({
        type:LOAD_USER_REQUEST,
    })
    context.store.dispatch({
        type:LOAD_POSTS_REQUEST,
    });
    context.store.dispatch(END);//LOAD_POSTS_REQUEST에 대한 응답이 올때까지 기다림
    await context.store.sagaTask.toPromise();
});

- getServerSideProps에서 context.store의 상태가 변하면, reducer>index.js에서 HYDRATE가 받음
  (처음에 있던 코드도 수정해서 아래 코드 처럼 만듬)
  const rootReducer = (state, action) =>{
    switch (action.type){
        case HYDRATE:
            console.log('HYDRATE',action);
            return action.payload;
        default:{
            const combineReducers = combineReducers({
                user,
                post
            });
        }
        return combineReducers(state,action);
    }
}


(예전6-3) getInitialProps로 서버 데이터 받기
- 게시글에서 글제목과 avartar 눌렀을때, 게시자 정보 가져오기
- _appjs와 pages>hashtag,user에 getInitialProps를 추가해줘야 함
 - _appjs에서의 context는 next에서 넣어줌
- next의 getInitialProps는 react에서의 lifecycle method와 유사
  - /hashtag 전체 프로세스
   next는 _appjs의 getInitialProps을 최초로 실행시키고(componentDidmount보다 먼저 실행)
   context 값을 줌(route: '/', pathname: '/', query: {},asPath: '/',)
   ##추가-context의 component에는 최초로 homejs가 들어있고, getInitialProps속성작성하면 추가됨
   ##내생각 - 이 단계에서 서버와 비동기통신후 초기 로딩에 필요한 데이터를 context에 담는 듯
   게시글의 해시태그(#kbs)를 클릭하면 주소가 /hashtag/kbs로 변경되고, 
   pages>_appjs>context 속 Component에 hashtag가 담기게 되고, hashtag.getInitialProps에
   ctx를 넘겨주면서 비동기 통신을 함 await hashtag.getInitialProps(ctx) 
   *_appjs context에 '/hashtag', { tag: req.params.tag })내용도 담기는 듯
   pages>hashtag의 getInitialProps가 실행된 후값을 return 받아서 
   _appjs의 pageProps에 담기고, _appjs는 이 pageProps를 다시 다른 components 들에게 
   props로 사용하게 함
   (getInitialProps는 서버에서도 실행됨. 서버에서도 실행되므로, 서버에서 실행될 코드를 입력함. 
   이는 서버사이드랜더링에서 중요함 - 원래 spa는 최초 빈페이지를 랜더링하고 추후에
   서버에서 데이터를 받아오는데, 서버사이드랜더링을 하면 미리 getInitialProps를
   통해서 서버에서 데이터를 받아와서 front를 랜더링 할 수 있게됨)
   
 - getInitialProps설명 사이트주소
 - 최초 페이지 로드시, getInitialProps는 server에서만 실행되고, 
 next/link나 next/router을 통해 다른 페이지로 이동할때, client에서도 실행됨
 https://nextjs.org/docs/api-reference/data-fetching/getInitialProps



//6-2 SSR시 쿠키 공유하기
- getServerSideProps는 front서버에서만 실행됨
- pages>index.js 아래 코드 추가
 // context.req가 있으면 서버에서 실행됐다는 의미 임
    const cookie = context.req ? context.req.headers.cookie : '';
    axios.defaults.headers.Cookie = '';
    if(context.req && cookie){
        axios.defaults.headers.Cookie = cookie;
    }
 
 => 최초 페이지 로딩시에만 header에 쿠키를 넣고, 이후에는 지워줘야 함
    안 지우면, 다른 사람이 프론트 서버에 최초로 접속했을 때, 그 쿠키정보가 공유되게 됨


(예전7-2) SSR을 위해 쿠키 넣어주기
- Applayout 에서 useEffect 내용(유저정보불러오는) _app.js로 옮긴후, 형식에 맞게 수정함 
  getInitialProps는 페이지에서만 사용할 수 있음
- 코드 수정후에 에러남
- saga>user에서 loadUserAPI withCredentials이 정상 작동이 안되서 그럼
  function loadUserAPI(userId) {
  return axios.get(userId ? `/user/${userId}` : '/user/', {
    withCredentials: true,
  });
  }
- **정상작동 안하는 이유 중요함***************************
  client랜더링에서는 axios로 브라우저를 거쳐서 back서버와 통신을 했음
  client->axios->브라우저에서 withCredentials보고 쿠키를 함께보냄->back서버  
  하지만 SSR에서는 front express 서버가 브라우저를 거치지않고 직접 back서버와 통신하는데
  브라우저에서 쿠키를 넣어주는 단계가 없어서 쿠키없이 통신을 하게되고
  사용자의 로그인 상태를 파악하지 못하게 됨 (쿠키로 사용자의 로그인 상태를 파악)
  따라서 직접 쿠키를 넣어줘야 함
  _appjs에서 아래코드처럼 수정
  //ctx.req와 res는 서버환경에서만 존재해서 클라이언트환경에서는 undefine으로 에러남
  //서버일때만 쿠키불러오도록 수정
  const cookie = ctx.isServer? ctx.req.headers.cookie : '';
  // 클라이언트에서 실행되면 cookie 안넣게, 서버에서 실행될때만 cookie 넣음
  if(ctx.isServer && cookie){
    // axios.defaults 다른 곳에서도 적용됨
    axios.defaults.headers.Cookie=cookie;
  }  
- 새로고침해도 로그인 정보 그대로 있음  


//6-3 getStaticProps 사용해보기
- pages>about.js 생성
- 언제 접속해도 데이터가 바뀔 일이 없을때 사용 -사용하기 까다로움
 ex) 블로그 게시글-한번 게시글을 쓰면 바뀌지 않음
  - 미리 html로 바꿔 놓고 방문자들에게 html을 제공함  
- 접속할 때마다 데이터가 바뀌면 getServerSideProps 사용-주로 사용됨

//6-4 다이나믹 라우팅 [id].js
- 개인별 포스트 페이지 만들때 용이하게 사용
- pages>post>[id].js 생성 => //post/1.js,post/2.js,...
- reducer, saga에서 LOAD_POST 3종세트 작성
- routes>post 
  router.post('/:postId',isLoggedIn,async(req,res,next)=>{ // GET /post/1 

- /post/1, /post/1 하면 계속 오류나 났는데, 이유는 1,2post를 지웠었기 때문!! workbench보고 알았음

(예전6-5) Link컴포넌트 고급 사용법
- 해시태그 누르면 새로고침 되는데 spa는 새로고침되면 안됨
 - front>components>postCard에서 Card>Card.Meta>avatar>Link에서
 - Link href={`/user/${post.User.id}`} 주소를 front>serverjs>express에서 처리하기 때문
 - express에서 재랜더링을 하게 되어있음 app.render(req, res, '/user'~)
 - 여러 Link의 주소를 수정 href={{pathname:'/user', query:{id:post.User.id}}
 - 그런데 주소가 ?tag=kbs 형식으로 지저분함
 - Link의 속성으로 as={`/user/${post.User.id}`}를 추가함
 - 내코드는 pages>user에서 계속 오류나는데 원인을 모르겠음

 - favicon.ico => front>public 폴더 생성후 넣어 줌
 

//6-5 CSS 서버사이드랜더링
- 새로고침하면 이메일 폼에 줬던 padding이 나타나지 않고, 다른페이지로 넘어갔을때, 적용됨
 =>  CSS가 서버사이드랜더링이 적용되지 않아서 발행하는 문제
- babel설정 변경 
 - npm i babel-plugin-styled-components
 - front>.babelrc
   {
    "presets": ["next/babel"],
    "plugins": [
        ["babel-plugin-styled-components",{
            "ssr":true, //서버사이드랜더링 true
            "displayName":true //개발모드에서 콤포넌트이름이 보기좋게 변경
- _document.js 작성
 - polyfillio 홈페이지 > create a polyfill bundele > default, es2015 es2016 es2017 es2018 es2019선택 후 URL복사 
   <NextScript /> 보다 위에 작성
    render() {
    return (
      <Html>
        <Head />
        <body>
          <Main />
          <script src="https://polyfill.io/v3/polyfill.min.js?features=default%2Ces2015%2Ces2016%2Ces2017%2Ces2018%2Ces2019"></script>
          <NextScript />
        </body>
      </Html>


(예전7-15) styled-components 
- component>imagesZoomjs 수정
- ant design에서 가져온 Icon 콤포넌트 스타일 덮어쓰는 법
  const CloseBtn = styled(Icon) ` 코드 `
- 콤포넌트를 계속 만들게 되면 변수명도 계속 지어줘야 되는데,
  대표적인 콤포넌트만 styled 콤포넌트로 만들어주고 자식은 해당 콤포넌트 안에서 &로 적용시킴


(예전7-16) styled-components SSR
- postman에서 보면 styled-components에 스타일 적용이 안되어 있음 => SSR해야 함
- _document에서 ServerStyleSheet로 불어온 후 App을 감쌈
  import { ServerStyleSheet } from 'styled-components'; 
  sheet.collectStyles(<App {...props} />

- SSR 했는데도 postman에서 적용이 안됨 -> postcard에 적용해보고 실제 스타일이 적용됐는지 판단
 - ant design 적용시 넣어줬던 link 태그에서의 주소를 못불러옴
 - styled components는 실제 랜더링 후에 적용이 됨
 - postman에서 style 적용됐는지 판단하기 힘듬


//6-6 사용게시글, 해시태그 게시글
- pages>user>[id].js 추가 => zerocho github에서 내용 복사 붙여넣기 함
- 특정사용자의 게시글만 불러옴
- reducer>post> LOAD_USER_POSTS_REQUEST, LOAD_HASHTAGPOSTS_REQUEST 3종세트 만듬
 - reducer를 같이 사용하는데, 한 page에서 동시에 dispatch하지 않으면 같이 사용할 수 있다고 함
- saga>post 3종세트 작성
- routes>user, hashtag 작성
- pages>hashtag>[tag].js 추가 => zerocho github에서 내용 복사 붙여넣기 함
- saga>post.js
 - axios로 요청을 보낼때 주소에 한글이나 특수문자 있으면 encodeURIComponent()로 감싸야 함
 //TypeError [ERR_UNESCAPED_CHARACTERS]: Request path contains unescaped characters
  function loadHashtagPostsAPI(data,lastId) { //주소에 한글 넣을 때, 아래와 같이 해줘야 함
  return axios.get(`/hashtag/${encodeURIComponent(data)}?lastId=${lastId || 0}`);
}
- route>hashtag => 라우트에서는 decodeURIComponent(req.params.tag)하면 원래글자로 변환
 where: { name: decodeURIComponent(req.params.tag) },//include 한 모델의 조건

//6-7 getStaticPaths
- 다이나믹 라우팅에서 getStaticProps와 같이 사용 함
- 잘 안쓸거같아서 필기 안 함


//6-8 swr 사용해보기
- npm i swr
- pages>profile.js => swr로 코드 수정함
- SWR은 서버사이드랜더링도 됩
- route>user.js 에서 조심해야할 사항!!
 - router.get('/:userId',~)
  => /:userId params는 와일드 카드라서 user/** 다음에 나오는 모든 주소들이 걸릴 수 가 있음
    따라서 /:userId 이런 라우터들은 아랫쪽에 적어야 함

- 불러올 갯수를 제한 함 / followersLimit, followingsLimit
- useSWRInfinite가 생길 수 있다고 함, 인피니트 스크롤링 지원
- useEffect에 followerData의 id로 비교해서 기존 state에 concat하면, 3,6,9개씩 불러 올때
  6개 불러올때 기존 있던 3개도 다시 불러오고, 9개불러올때, 기존 있던 6개도 다시 불러오는 낭비를 줄일 수 있다고 함 

(예전7-6) 페이지네이션
- 팔로잉, 팔로워목록이 천단위 이상으로 증가한다면 목록을 한번에 불러올 수 없음
  사람이 불러올 수 있는 정도만 불러온 후 더보기를 누르면 더 불러오도록 함
- profile에서 팔로잉 목록을 3명만 보여주고 나머지는 더보기버튼을 눌러야 보이게 함
  더 불러올 사람이 업으면 더보기 버튼 사라지게 함
- limit, offset(다른말로 skip)
- 데이터를 불러올때부터 데이터 갯수를 조절해서 불러옴
  한번에 불러오는 단위를 limit이라고 부름 
  3개씩 데이터를 불러올때 limit은 3이되는데, 최초 3개를 불러온 후 
  다음 3개부터는 최초 3개씩을 건너뛰고 불러와야 함
  이렇게 건너뛰는 부분을 offset으로 설정함
- saga>user에서 offset 설정함 
  function loadFollowersAPI(userId, offset=0, limit=3) {
    // 서버에 요청을 보내는 부분
    return axios.get(`/user/${userId || 0}/followers?offset=${offset}&limit=${limit}`, {
      withCredentials: true,
    });
  }
  function loadFollowingsAPI(userId, offset=0, limit=3) {
    // 서버에 요청을 보내는 부분
    return axios.get(`/user/${userId || 0}/followings?offset=${offset}&limit=${limit}`, {
      withCredentials: true,
    });
  }
- route > user
  router.get('/:id/followings' / router.get('/:id/followers' 에서 
  const followers = await user.getFollowings 밑에 써줌
  attributes:[~],
  limit:parseInt(req.query.limit,10),
  offset:parseInt(req.query.offset,10),

- profile에서도 offset 추가
  const loadMoreFollowings = useCallback(()=>{
    dispatch({
      type:LOAD_FOLLOWINGS_REQUEST,
      offset:followingList.length,//limit이 3이므로 0~3이 들어감
    })
  },[followingList.length])

  const loadMoreFollowers = useCallback(()=>{
    dispatch({
      type:LOAD_FOLLOWERS_REQUEST,
      offset:followerList.length,//limit이 3이므로 0~3이 들어감
    })
  },[followerList.length])

- saga>user에서 offset 추가함
  const result = yield call(loadFollowersAPI, action.data, action.offset);
  const result = yield call(loadFollowingsAPI, action.data, action.offset);

- 더보기 누르면 남은 데이터를 가져오는데, 기존의 데이터를 대체해 버렸음
- 그런데 내 화면에서는 팔로잉, 팔로워 목록을 새로고침야 불러오고, 
  로그아웃을 해도 목록 내용이 그대로 남아 있음, 새로고침해야 사라짐
 - 프로필 페이지에서 로그인하면 데이터를 바로 못불러오고 바로 못지움
   새로고침이나 프로필 버튼을 누른 후에 데이터들이 수정됨

- reducer>user에서 기존���록에 추가되게끔 코드 수정
  followerList: state.followerList.concat(action.data)
  followingList: state.followingList.concat(action.data),

- 정상작동 됨


(예전 7-7) 더보기버튼
- 다음에 불러올 데이터가 없다면 더보기 버튼 없애기
- 생각보다 로직이 복잡함
- reducer > user > FOLLOWERS 아래처럼 수정, FOLLOWINGS도 동일하게 수정
  case LOAD_FOLLOWERS_REQUEST: {
    return {
      //어느곳에든 프로필화면으로 가면 데이터가 초기화되고 다시 불러옴 
      //offset:followingList.length이므로 처음 action.offset는 false가 됨
      //초기화 후 데이터 불러올 때(action.offset=false)는 더보기 버튼 true, action.offset으로 데이터 불러올때는 
      // state.hasMoreFollower 넣는데, 그냥 아무 영향없이 그대로 놔둔다는 의미
      ...state,
      hasMoreFollower: action.offset ? state.hasMoreFollower : true, 
    };
  }
  case LOAD_FOLLOWERS_SUCCESS: {
    return {
      //데이터를 가져왔는데 1개거나 2개면 더보기 버튼을 없애고, 3개면 다음데이터가 있을 수 있으므로 
      //더보기 버튼을 보여줌
      ...state,
      followerList: state.followerList.concat(action.data),
      hasMoreFollower : action.data.length === 3,
    };
  }

- profile>list>loadmore에서 
  loadMore={hasMoreFollowing && <Button style={{ width: '100%' }} onClick={loadMoreFollowings}>더 보기</Button>}
  loadMore={hasMoreFollower && <Button style={{ width: '100%' }} onClick={loadMoreFollowers}>더 보기</Button>}

- 전체 프로세스-----------------------------
  profile페이지접속 -> 데이터 초기화 -> _appjs getInitialProps SSR -> profile getInitialProps SSR ->
  followers, followings, user posts 로드 dispatch -> saga > offset:0, limit:3 통신 -> 
  route>limit:3 3개데이터보냄 -> profile 랜더링 -> 더보기 버튼클릭 -> offset에 불러왔던 데이터수(0~3)를
  넣어서 dispatch -> saga -> route -> reducer 


//6-9 해시태그 검색하기 (특정 유저 검색도 포함)
- Applayout.js
 - next router는 프로그래밍상의 주소이고 실제 주소의 변경은 Link사용

- 전체프로세스-------------------------------
 - page>Applayout.js에서 해시태그 검색버튼 클릭	=> onSearch 함수실행
    const onSearch = useCallback(()=>{Router.push(`/hashtag/${searchInput}`)
   =>	pages>hashtag => getServerSideProps 서버사이드 랜더링 
   => context.store.dispatch({ type: LOAD_HASHTAG_POSTS_REQUEST, data: context.params.tag,
   => route>hashtag 라우터에서 해당 해시태그 가진 게시글 모두 찾아서 넘김
   => pages>hashtag에서 랜더링

- components>PostCard.js 수정
- components>UserProfile.js 수정 => zerocho github에서 복사 붙여넣기 함

(예전7-17) 기타 기능구현과 질문
- 검색창 기능 구현
- AppLayout> Input.Search onSearch={onSearch} 추가함
 - 콤포넌트적으로 페이지를 전환하는 것은 Link이고, 프로그래밍적으로는 Router라고 함
  import Router from "next/router";
  const onSearch = (value)=>{ 
    //첫번째 인자는 내부적으로 접근하는 주소 = 페이지주소 -> express 서버에서 읽음
    //두번째 인자는 외면적으로 보일 주소
    //이렇게 하는 이유는 동적라우팅할때 serverjs에서 서버주소와 front-edn주소를 다르게 지정했기 때문
    //내부적주소는 '/hashtag', 외부주소는 /hashtag/:tag'
    // server.get('/hashtag/:tag', (req, res) => {
    //   //app은 next임, pages>_app.js,hashtag에 req.params.tag를 전달하고, 랜더링
    //   // console.log('server.get(/hashtag/:tag)',req.params)
    //   return app.render(req, res, '/hashtag', { tag: req.params.tag });
    // });    
    Router.push({pathname:'/hashtag', query:{tag:value}}, `/hashtag/${value}`)
  }

- 해시태그 검색이 안됨-> 기존 포스트가 초기화되지 않았기 때문

- reducer>postjs>LOAD_USER_POSTS_REQUEST를 lastId가 없으면 으로 수정
  draft.mainPosts = !action.lastId ? [] : draft.mainPosts;

- 전체process
- 찾을 해시태그 입력 후 클릭 -> 해시태그가 value가 onSearch 함수에 전달 -> 
  Router.push에서 /hashtag?tag=value 주소입력-> express server에서 받아서 /hashtag 주소로 회신
  -> Router.push의 2번째 인자에 의해서, 주소창에 /hashtag가 아닌  /hashtag/${value}로 보임

- 해시태그 찾기 잘됨, 그런데 해시태그 뿐아니라 다른 게시글들도 찾기가 안되나?  

- userprofile에서 짹짹,팔로잉,팔로워 누르면 profile 나오게 Link 추가
- 팔로잉목록이 6개가 됨, -> LOAD_FOLLOWERS_REQUEST를 2번 호출되기때문에 생기는 문제
- reducer > user에서 offset이 없으면 following 목록을 초기화하게 함
  case LOAD_FOLLOWERS_REQUEST: {
    draft.followerList = !action.offset ? [] : draft.followerList;
    draft.hasMoreFollower = action.offset ? draft.hasMoreFollower : true; // 처음 데이터를 가져올 때는 더보기 버튼을 보여주는 걸로
    break;
  }

- 기타 에러나는 것들 해결
 1)The prop `pageProps` is marked as required in `NodeBird`, but its value is `undefined`.
   _app에서 pageProps 기본값 넣어주거나 pageProps:PropTypes.object.isRequired에서 isRequired을 빼면됨
   pageProps = await Component.getInitialProps(ctx) || {};  기본값 넣어줌
 2)Failed prop type: Invalid prop `post.createdAt` of type `string` supplied to `PostCard`, expected `object`
  postCard에서 createdAt 타입을 string으로 수정
  createdAt: PropTypes.object, => createdAt: PropTypes.string,
  Card key={+post.createdAt}에서 key 제거

- key={+c.createdAt}에서 +쓰는이유? new Data():Tue May 2019~ / +new Data():숫자로 표시
 - 객체를 숫자로 형번환 해주기 위해
- 자바스크립트에서는 1 + 2에서의 +와 +5에서의 +가 다른의미
  다항+/단항+ 차이 => 둘 사이의 무슨 차이 있는지는 추후 검색해 보자
- styled component 문법에서 빽태크 ``의 의미 => 함수 호출 
  a() = a`` 동일한 의미 헉~
- zerocho.com > ECMAscript에 정리되어 있다고 함


//6-10 moment와 next빌드하기
- npm i moment
- component>PostCard
 - moment.js 홈페이지 들어가면 현재로부터 얼마나 시간 지난는지 등 여러가지 dateformat 제공됨
  moment.locale('ko'); //한글로 변경
  <div style={{float:'right'}}>{moment(post.createdAt).format('YYYY.MM.DD')}</div>

- 깃헙에 push하면 cicd툴을 이용해서 코드를 테스트해주고, build도 해줌
  중간에 에러있으면 알림 

- npm run build *back서버를 실행한 상태에서 빌드를 해야 함.(back꺼놓고 했더니 계속 오류낫음)

(예전7-18) 폴더구조와 _error.js
- component>imagesZoom 폴더와 그 폴더에 index.js와 style.js 파일 생성
- imagesZoomjs에서 콤포넌트를 수정한 다음, 각 styled컴포넌트를 모듈로 사용할 수 있도록
  style.js에 옮겨 적음
  
- contaniers와 component 폴더 구별하기도 함
 - containers : dispatch 하는 파일들 / component:순수 표현 콤포넌트
 - 나눌거면 프로그래밍 처음부터 나눠서 작성하는것이 좋음
 - containers폴더로 파일 옮기고 나서 해당 콤포넌트 import하는 파일들도 수정

- _error.js 추가 후 작성

- _appjs>공식문서에서는 아래 코드도 작생해야 한다고 나오는데, 안써도 에러는 안남
//혹시 에러나 났는데 모른다고 하면 아래 코드 추가해 볼것
// class NodeBird extends App {
//   static getInitialProps(context){
//   }
//   render(){


(예전8-1) favicon서빙과 prefetch
- front static 폴더 생성 - public폴더로 지정
- front/server.js 
  //front주소 '/',express.static은 서버측주소
  server.use('/',express.static(path.join(__dirname,'public')));
  
- 노드버드 메인화면에서 프로필 화면으로 넘어갈때 로딩 시간이 김
- AppLayout에서 Link에 prefetch를 달아줌 -> next에서 prefetch가 적힌 페이지를 불러올때
  profile 페이지도 같이 불러옴 ex)AppLayout 페이지가 불릴때, prefetch가 적힌 profile페이지도 같이 불러옴
  Menu.Item key="profile" Link href="/profile" prefetch> a프로필/a /Link /Menu.Item
- userProfile에서 Link 태그에서도 prefetch 속성을 줌
- prefetch 너무 많은곳에 주면 코드 split한 효과가 반감 
 - 사용자가 자주 다니는 콤포넌트의 Link에만 넣어 줄것
 - prefetch가 된 것은 개발환경에서는 볼수 없고 배포환경에서만 볼 수 있음

- 갑자기 아래와 같은 에러가 나는데 원인을 못찾겠음
  Error: React.Children.only expected to receive a single React element child.
- AppLayout과 UserProfile을 zerocho github에서 가져와서 붙이니깐 잘 됨
- <Link href="/"> <a>노드버드</a> </Link> 안에 공백때문이었음 헉


//6-11 커스텀 웹팩과 bundle-analyzer
- npm i @next/bundle-analyzer 
- 처음에 하던 웹팩 설정 중간에서 멈추고 next/bundle-analyzer사용하면서 코드 수정함.
- 배포 때는 'hidden-source-map' 써야 한다고 함.

*소스 맵(Source Map)----------------------------------------------------------------------
 소스 맵(Source Map)이란 배포용으로 빌드한 파일과 원본 파일을 서로 연결시켜주는 기능입니다.
 보통 서버에 배포를 할 때 성능 최적화를 위해 HTML, CSS, JS와 같은 웹 자원들을 압축합니다. 
 그런데 만약 압축하여 배포한 파일에서 에러가 난다면 어떻게 디버깅을 할 수 있을까요? 
 이렇게 추적, 디버깅이 어려운 경우 Source map 을 이용해 배포용 파일의 특정 부분이 
 원본 소스의 어떤 부분인지 확인하는 것입니다. 즉, 원본 파일을 통해 코드를 보여주고 
 error 및 warning 메세지와 함께 정확한 파일명과  코드 위치를 알려주기 때문에 유용할 수 있습니다.

 // webpack.config.js 
  module.exports = { devtool: 'cheap-eval-source-map' }

 webpack 공식 문서에서는 개발 모드에서는 eval-source-map 또는 cheap-eval-source-map를, 
 운영 모드에서는 none(사용하지 않음) 이거나 hidden-source-map 정도를 권장하고 있습니다.
 출처: https://webclub.tistory.com/637 [Web Club]------------------------------------------

- package.json
  next.config.js는 npm run build할때 실행되는데, 이때 process.env도 수정할 수 있음
  "build": "ANALYZE=true NODE_ENV=production next build"
  => 그런데 window에서는 안되서 npm i cross-env를 설치하고 아래처럼 수정
  "build": "cross-env ANALYZE=true NODE_ENV=production next build"

- npm run build *back서버를 실행한 상태에서 빌드를 해야 함.(back꺼놓고 했더니 계속 오류낫음)
- .next폴더에 build한 파일이 모여있음
- next/bundle-analyzer가 client와 back서버의 용량을 시각한 웹페이지를 보여주는데, 
  이 사진을 보고 줄일 수 있는 파일은 줄임, 1mb보다 적기만 하면 됨.
 - 강의에서는 moment.js가 다국어를 지원해서 용량이 크게 나와서, goole 검색을 해서 방법을 찾음
   next.config.js 파일을 수정
    webpack(config, { webpack }) {
    const prod = process.env.NODE_ENV === 'production';
    const plugins = [
      ...config.plugins,
      new webpack.ContextReplacementPlugin(/moment[/\\]locale$/, /^\.\/ko$/),
    ];

(예전8-2) next.config.js 
- 패키지 최적화
- 현재까지는 next에서 babel와 webpack을 설정한 것을 그대로 사용했음
  그런데 이제는 수정을 해서 패키지 간 최적화될 수 있도록 함
- front>next.config.js 파일 생성
  아래 사이트는 config.js 파일에 대해서 설명해 놓은 사이트
  https://nextjs.org/docs/api-reference/next.config.js/introduction

- .next 폴더안에 build한 파일들이 들어감
  next.config.js에서 .next 폴더를 수정하려면 distDir로 수정가능한데 굳이 바꿀필요없음

- webpack 기존 config 설명 : 강사님 config와 내 config 파일이 다름
  module.rule - 최신문법 쓸 수 있게 설정
  DefinePlugin - 변수에 값을 넣어주거나, 변수를 문자열로 대체
  ReactLoadablePlugin - 코드스플리팅 해주는 플러그인
  HotModuleReplacementPlugin,NextJsRequireCacheHotReloader - 코드수정했을때, 바로 화면에 반영해줌
  NextJsSsrImportPlugin - 서버사이드랜더링 관련 플러그인

- 패스트캠퍼스 프론트엔트(리액트) 웹팩 강의 수강
 - 강의자료 필기한거 fast-webpack.html파일에도 적음


(예전8-3) next-bundler-analyzer 
- npm i @next-bundle-analyzer 
- front의 패키지를 분석함 
 - next webpack bundle analyzer 검색 -> github 페이지 
 - 사용방법이 달라졌고, 강의내용대로 적용하는 건 추천하지 않는다고 하는데, 
   난 그냥 강의내용대로 함
 - next.config.js 수정 -> 웹사이트에 있는 코드 그래도 붙이고, 감쌈
 - analyzeServer: ["server", "both"].includes(process.env.BUNDLE_ANALYZE),
   analyzeBrowser: ["browser", "both"].includes(process.env.BUNDLE_ANALYZE),
   => BUNDLE_ANALYZE 환경변수를 both라고 설정하면, front와 express server 둘다 분석해줌

   https://github.com/zeit/next.js/tree/canary/packages/next-bundle-analyzer

- npm run build를 하면 아래와 같이 설정이 수정됨
 - webpack mode: 'production' / name:'client' / target: 'web'
 - 난 강사님과 결과가 다르게 나옴, _app.js에 getInitialProps을 최적화가 안된다는 거 
   같은데, 고치는 방법을 모르겠음

  Warning: You have opted-out of Automatic Static Optimization due to `getInitialProps` in `pages/_app`.
  Read more: https://err.sh/next.js/opt-out-auto-static-optimization
  
  Page                                                           Size     First Load
  ┌ λ /                                                          1.35 kB      239 kB
  ├   /_app                                                      31.4 kB      208 kB
  ├ λ /_error                                                    408 B        209 kB
  ├ λ /hashtag                                                   625 B        238 kB
  ├ λ /post                                                      2.17 kB      210 kB
  ├ λ /profile                                                   1.38 kB      239 kB
  ├ λ /signup                                                    378 B        209 kB
  └ λ /user                                                      1.14 kB      238 kB

-next.config.js에서 
 - analyzeServer: ["server", "both"].includes(process.env.BUNDLE_ANALYZE),
   analyzeBrowser: ["browser", "both"].includes(process.env.BUNDLE_ANALYZE),
   => BUNDLE_ANALYZE 환경변수를 both라고 설정하면, front와 express server 둘다 분석해줌
 - 환경변수는 package.json scripts에서 설정가능한데, window에서는 cross-env를 설치해줘야함
   그런데 set과 && 붙이면 됐었음
  - npm i cross-env
    "build": "cross-env BUNDLE_ANALYZE=both next build",
  - cross-env설치 후 npm run build하면 build잘됨  
  - build된 후에 웹브라우저로 front와 server의 파일 크기에 대한 이미지 파일을
    BUNDLE_ANALYZE가 제공하는데, ant 디자인의 icon이 가장 큰 파일을 차지한다고 나옴
    front static은 Parsed size가 1mb정도가 적당하다고 함 (한국외에는 500kb이하로)
    파일이 큰 것을 찾아서 압축시켜야 함
  
  - 구글링 ex) ant design icons treeshaking,tree shaking problem for icons
    => 그런데 많은 사람들이 ant design은 안된다고 함
  - ant design 말고 다른 icon 사용해야 함 ex)font awsome, bootstrap


(예전8-4) tree shaking 예제와 gzip
- tree shaking 예제
- npm i moment // 추천 패키지 luxon, date-fns
- containers>Postcard
  import moment from 'moment';
  moment.locale('ko');//한글지원
  
  <Card>~{moment(post.createdAt).format('YYYY MM:DD.')}</Card>

- npm run build
- BUNDLE_ANALYZE에서 제공하는 이미지 파일 보면 ant design보다 
  moment 파일이 더 크다고 나옴, 아마 나는 ant design을 다른 방법으로 추가해서 그런듯
  moment 파일들은 통째로 큰 파일이 아니라 작은 파일들로 나뉘어져 있기 때문에
  검색하면 tree shaking 할 수 있을 것
- next.config.js> 아래사이트에 있는 코드에 ...config.plugin,추가후 붙여넣음
  const webpack = require('webpack');
  https://github.com/jmblog/how-to-optimize-momentjs-with-webpack  


- package.json에서 prestart 추가:start전에 실행되는 명령어
 - start하면 prestart가 먼저 실행되고 build를 먼저 한 후 start됨
 - poststart도 있다고 함
 "scripts": {
    "dev": "nodemon",
    "build": "cross-env BUNDLE_ANALYZE=both next build",
    "prestart": "npm run build",
    "start": "cross-env NODE_ENV=production next start"
  },

- npm run build => moment파일 아주 작아졌음 336kb => 56kb / locale에 ko 하나만 남았음

- 강의에서 ant design 관련되서 next.config파일 수정했는데 나는 안하고 넘어감

- gzip : 보통 1/3~1/4로 압축됨, 파일확장자를 .gz으로 만듬
- npm i compression-webpack-plugin
- next.config.js
  const CompressionPlugin = require('compression-webpack-plugin');
  plugins:[~, prod && new CompressionPlugin(),] //배포시만 압축,main.js.gz

 => 위 코드 다시 수정함 npm run dev 하면 개발환경에서 에러나서 수정 / 나는 에러는 안났음
- npm run build => .gz 확장자가 붙음
- 서버가 브라우저에 .gz 압축파일로 보내면, 브라우저가 다시 js파일로 복호함


//6-12 배포 전 Q&A
- model 최신문번 적용하기 class문법 => typescript로 작성할때 도움이 된다고 함, 나는 안 바꿈
- immer가 익스플로러에서 적용이 안된다고 함
 - util/produce.js작성
    import { enableES5, produce } from 'immer';
    export default (...args) => {
      enableES5();
      return produce(...args);
    };
- reducers에서 import produce from '../util/produce'


7장 AWS에 배포하기
//7-1 EC2생성하기
 - 강의와 예전 fastcampus 쇼핑몰 수업강의자료보고 생성
 - prepare폴더 생성 후 back과 front폴더 옮김
 - .gitignore 생성 후 작성
  - github에 push하지 않을 파일들 적음
 - prepare폴더에서 git init
  - git 폴더로 만듬 .git 생김
  - git remote add origin 'github 주소'
  - git add .
  - git commit -m "aws~"
  - git push origin master
 - .gitignore이 제대로 적용 안됏으면 github repo 삭제 후 재생성 해야 함.
 
 - EC2 front 연결 
  - 로컬컴퓨터 git bash > ssh -i "test.pem" ubuntu@ec2-3-34-90-243.ap-northeast-2.compute.amazonaws.com
  - git clone github 주소
  - EC2 front 서버로 이동 함 cd react-nodebird/front  

//7-2 우분투에 노드 설치하기
 - EC2 front 서버
  - 리눅스에서 node 설치 명령어 
   - sudo apt-get update
   - sudo apt-get install -y build-essential 
    => bcrypt와 shape(이미지리사이징) 등의 설치를 위해 필요
   - curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash --
    => 설치 파일이 있는 주소를 입력하고 다운받아라 | 관리자권한으로
   - sudo apt-get install -y nodejs
   
  - npm i 
  - npm run build 프론트에서는 빌드부터 해야 함
   => 아직 db연결 안됐고, EC2 back url, 포트번호 때문에 빌드오류남
  
  - 로컬 컴퓨터 front 
   - getStaticProps들 주석처리
   - front>config> config.js 생성 후 작성
     export const backUrl = process.env.NODE_ENV === 'production' ? 'http://13.209.99.201' : 'http://localhost:3065';
   - saga index, ImageZoom, postform, postImage 콤포넌트 url수정
   - package.json : 포트 3060->80
    "scripts": {
      "dev": "next -p 3060",
      "build": "cross-env ANALYZE=true NODE_ENV=production next build",
      "start": "cross-env NODE_ENV=production next start -p 80"
    },
   - 수정 후 git add, commit, push

  -EC2 front
   - git pull  

//7-3 우분투에 MySQL 설치하기
- EC2 back 연결 
  - 로컬컴퓨터 git bash > ssh -i "test.pem"~
  - git clone github 주소
  - EC2 back 서버로 이동 함 cd react-nodebird/back
  - nodejs 설치
  - npm i 

  //mysql 8버전 다운로드 참고 사이트 https://awakening95.tistory.com/2
  - sudo wget -c https://dev.mysql.com/get/mysql-apt-config_0.8.13-1_all.deb
  - sudo dpkg -i mysql-apt-config_0.8.13-1_all.deb 
    => 빨간색 MySQL server & cluster (currently selected:mysql 5.X) => 엔터 => mysql 8.0 선택 후 엔터
    => 빨간색 MySQL server & cluster (currently selected:mysql 8.0) 확인 후 맨 아래 ok 클릭
  - sudo apt update
  - sudo apt install -y mysql-server
    => 분홍색 package configuration 창 뜸 => root password 입력
    => 장문의 영문글 ok가 잘 안쳐지는데, 방향키 우측키를 사용하면 빨간색으로 ok 클릭할 수 있음 => ok클릭
    => Use Strong Password Encryption (RECOMMENED) 클릭 => ok

  - sudo su (root로 변경/권한막강 => su ubuntu(다시 ubuntu 유저로))
  - sudo mysql_secure_installation 
    => Press y|Y for Yes, any other key for No: N => y로 하고 비밀번호를 다시 지정
    => 이것 이외의 것은 다 y로 하고, 비밀번호는 con~으로 지정 함
    
  - mysql -uroot -p (root권한일때만 접속가능)
    mysql> exit;  (;까지 쳐야 빠져나옴)

  - npm start가 안되서 package.json 수정함    
    "scripts": {
        "start": "node app.js",
        "dev": "npx nodemon -e js,html app.js"
      },
  - 내 로컬컴퓨터 터미널에서 진행
    git add package.json
    git commit -m""
    git push origin master

  - EC2 back 서버 git bash 터미널
    - .env를 만들어 줘야 함
    - vim .env 로컬과 동일한 env파일 만들어 줌
    - npm start를 하면 database에 접근을 할 수 없다고 나옴
    - 비밀번호를 다시 한번 변경함
    - sudo su : root계정으로 먼저 변경
    - mysql -u root -p
    mysql>ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '**';
    => mysql your password does not satisfy the current policy requirements에러 남
      MySQL이 새로 업로드 된후에 패스워드 정책이 변경 되어서 나는 에러

    mysql>SHOW VARIABLES LIKE 'validate_password%';
    +--------------------------------------+--------+
    | Variable_name                        | Value  |
    +--------------------------------------+--------+
    | validate_password.check_user_name    | ON     |
    | validate_password.dictionary_file    |        |
    | validate_password.length             | 8      |
    | validate_password.mixed_case_count   | 1      |
    | validate_password.number_count       | 1      |
    | validate_password.policy             | STRONG |
    | validate_password.special_char_count | 1      |
    +--------------------------------------+--------+
    제일 위의 validate_password_check_user_name은 패스워드에 user id가 들어갔는지 묻는것이다.
    필자의 경우 아이디와 패스워드가 모두 root인데 만약 on이 켜져있다면 이는 불가능하다.
    length는 당연히 길이를 의미한다. 8자 이상이어야 한다는 이야기이다.
    mixed case count는 대소문자를 적어도 1회이상은 써야한다는 것이다.
    밑의 nuber count도 숫자를 적어도 1회 이상은 써야한다는 것이다.
    마지막의 special char count는 특수문자를 적어도 1회 이상은 써야한다는 것이다.
    만약 위 정책을 끄고싶다면 이 파라메터가 low가 되어있어야한다.
    
    mysql>SET GLOBAL validate_password_policy=LOW;
    => 나는 정책은 그대로 두고 비밀번호를 까다롭게 함

  - vim .env에서 비밀번호 수정함
  - npx sequelize db:create
    => Database reactnodebird created.
  - npm start 
    => database 연결 잘됨, 그런데 EC2 ip 주소 때문에, port를 바꿔줘야 함
  - vim app.js
    const port = 3065 => 80; 으로 수정
  - npm start 
    => 잘 실행 됨

//7-4 pm2 사용하기 
 - pm2 : 백그라운드에서 서버 실행시켜 주는 프로그램
 - pm2 명령어
   sudo npx pm2 start npm -- start : pm2에서 npm 명령어 치기
   sudo npx pm2 list 로 리스트를 확인
   sudo npx pm2 stop id번호 => npx pm2 stop 1
   sudo npx pm2 kill
   sudo npx pm2 monit
   sudo npx pm2 logs
   sudo npx pm2 logs --err --lines 100 : 에러로깅
   sudo npx pm2 reload all : 재시작
 
 - EC2 back
  - npm i pm2 

 - 로컬 back : 배포모드로 수정
  - npm i cross-env helmet hpp 
  - app.js : hpp helmet cross-env 설치, cors에서 origin(허용 도메인에 EC2 front주소 추가)
    const hpp = require('hpp');
    const helmet = require('helmet');
    
    if(process.env.NODE_ENV === 'production'){
      app.use(morgan('combined'));//좀 더 자세히 로깅함
      app.use(hpp());
      app.use(helmet());
    }else{
      app.use(morgan('dev'));//요청들어오는 것을 기록으로 남김
    }
    app.use(cors({//쿠키를 주고 받을 수 있게 함
      //'*'-모든 요청을 받아줌, true-보낸곳의 주소가 자동으로 들어감 'http://localhost:3000'-해당 도메인만 허용
    origin: ['http://localhost:3060','nodebird.com','http://15.164.230.99'], 
    credentials: true,// true로 해야지 쿠키도 전달됨, front axios에서도 설정해줘야 함
   
 - package.jsone에서 script 수정
    "scripts": {
      "start": "cross-env NODE_ENV=production npx pm2 start app.js",
      "dev": "npx nodemon -e js,html app.js"   
 
  - git add, commit, push
  
 - EC2 back
  - sudo git pull
  - git reset --hard (충돌나면)
  - npm i (cross-env helmet hpp 추가설치)

//7-5 프론트 서버 배포하기
 - build 오류 사항 수정한 것들 7-2에 적어 놓음
 - EC2 front
  - npm i pm2 
  - npm run build
  - sudo npx pm2 start npm -- start : pm2에서 npm 명령어 치기
  - sudo npx pm2 reload all
 
 - 강사님은 EC2 mysql model 명이 대문자로 생성되어 있어서 오류났음
  - mysql 문법으로 drop한 다음 재생성하니깐 됐음
 => 회원가입 한 다음 홈 화면으로 안돌아가고, profile과 id 페이지 등은 오류 남
 

//7-6 Route53 도메인 연결하기
- 로그인 하면 로그인 풀리는 이유
 - 크롬 network창>Response Header 
 - set-cookie부분에 경고표시 떠 있고, 마우스올리면 samesite~ 때문이라고 나옴
 - 강사님은 도메인관련 경고표시가 뜨는데 나는 뜨지 않음
   Set-Cookie: rnbck=s%3AmtOCo8kpgKIWd2fVNpMAgksOcqEzNcBs.TysluB5DhRZwaZAuPfZalBACSYcG6pse6nBun%2FmYewY; 
   Path=/; Expires=Wed, 05 May 2021 08:33:40 GMT; HttpOnly

 - Cookie의 SameSite 속성은 서로 다른 도메인간의 쿠키 전송에 대한 보안을 설정
 - backend에서 쿠키를 보낼 때 samesite:"none"과 secure:true를 같이 
    app.use(expressSession({
    resave:false,
    saveUninitialized:false,
    secret:process.env.COOKIE_SECRET,
    cookie:{
      httpOnly:true,
      sameSite:"none",
      secure:true,
      maxAge:2000*60*60 //지속시간 2시간
    },

=> back app.sjs 세팅을 해도 여전히 로그인이 풀림

- 후이즈도메인에서 aserang.com aserang.co.kr 도메인 구매, 3년 계약
- 도메인 name server는 aws Route53에서 생성 한 aserang.com 호스트 영역의 라우팅 대상 값을 입력함
- 탄력적 IP할당 : front, back
 - 인스턴스와 연결하면 무료로 사용할 수 있음 => 인스턴스 연결해제 후에 탄력적IP도 release해줘야 요금안나옴
 - 탄력적 IP주소연결 => EC2 front, back과 연결
 - EC2 인스턴스의 IP가 고정이 됨

- Route53으로 가서 레코드 3개 생성
 - 레코드유형 A-IPv4~ | 값 EC2 front에서 할당받은 탄력적 IP주소 기입
 - 이름 api.aserang.com| 레코드유형 A-IPv4~ | 값 EC2 back에서 할당받은 탄력적 IP주소 기입
 - 이름 www.aserang.com| 레코드유형 CNAME (별칭) | 값 aserang.com

- 로컬 front>config 수정
 - export const backUrl = process.env.NODE_ENV === 'production' ? 'http://api.aserang.com' : 'http://localhost:3065';

- 로컬 back>app.js 수정
  app.use(cors({ 
	origin: ['http://localhost:3060','http://aserang.com'],

  app.use(expressSession({
	resave:false,
	saveUninitialized:false,
	secret:process.env.COOKIE_SECRET,
	cookie:{
		httpOnly:true,
		sameSite:"none",
		secure:true,
		domain: process.env.NODE_ENV ==='production' && '.aserang.com',//.aserang=>(.)점을 붙여야 api.aserang과 aserang과의 쿠키공유가능
		maxAge:2000*60*60 //지속시간 2시간
	},

- git add, commit, push

- EC2 front 
 - git pull, npm run build, npx pm2 start npm -- start 

- EC2 back
 - git pull 

=> 여전히 로그인 풀림  => https 문제 인듯

- https로만 접속할 수 있도록 설정한 것 수정하는 방법
 - chrome hsts삭제하는방법
 - https://jaimemin.tistory.com/1518


//7-7 S3연결하기
- 이미지 관리하는 서버 만들기
- aws>s3
 - 버킷만들기 > 버킷이름은 고유한 것으로 > 모든 퍼블릭 액세스 차단 해제 > 버킷만들기 
 - 권한 > 버킷정책 
    {
        "Version": "2012-10-17",
        "Statement": [
            {
                "Sid": "AddPerm",
                "Effect": "Allow",
                "Principal": "*",
                "Action": [
                    "s3:GetObject",
                    "s3:PutObject"
                ],
                "Resource": "arn:aws:s3:::aserang/*"
            }
        ]
    }
 - 내 보안자격증명 > 책세스키 > 새액세스키만들기 > 키파일다운로드(노출되면 안됨)

 - 로컬 back
  - npm i multer-s3 : multer를 이용해서 s3에 업로드 시 필요
  - npm i aws-sdk : aws s3의 접근권한을 얻게 해줌
  - .env에 S3 액세스 키 추가
  - routes>post.js 수정
    const multerS3 = require('multer-s3');
    const AWS = require('aws-sdk');
    const dotenv = require('dotenv');

    AWS.config.update({
      accessKeyId: process.env.S3_ACCESS_KEY_ID,
      secretAccessKey: process.env.S3_SECRET_ACCESS_KEY,
      region:process.env.S3_REGION,
    });

    const upload = multer({
      storage: multerS3({
        s3: new AWS.S3(),//S3의 권한(key, id)을 얻음
        bucket: process.env.S3_BUCKET,//버킷명
        key(req, file, cb) {
          cb(null, `original/${Date.now()}_${path.basename(file.originalname)}`)//버킷에 폴더를 만들어서 넣음
        }
      }),
      limits: { fileSize: 20 * 1024 * 1024 }, // 20MB
    });

    router.post('/images', isLoggedIn, upload.array('image'), (req, res, next) => { // POST /post/images
      console.log(req.files);
      res.json(req.files.map((v) => v.location)); //filename=>location
    });

  - git add, commit, push

 - 로컬 front
  - S3를 쓰면 이미지주소가 res.json(req.files.map((v) => v.location)); location에 담김
    따라서 backUrl을 써 줬던 곳을 다 지워야 함 | PostForm, PostImages, index
  
  - git add, commit, push

//7-8 Lambda로 이미지 리사이징하기(압축)
- EC2같은 컴퓨터보다 규모가 작은 함수 = lambda
- 로컬에서 prepare > lambda폴더생성
 - npm init
 - npm i aws-sdk sharp
 - index.js 
  - lambda는 aws실행되어서 자동으로 내 정보를 불러오기때문에 key를 입력할 필요가 없음
  - back 서버는 EC2에서 실행되기때문에 key를 입력해야 함
 - git add, commit, push

 -EC2 back
  - git pull 

- EC2 lambda 폴더로 이동
  - sudo su로 root 계정으로 한 후에도 sudo npm i 해야 함 : aws-sdk, sharp 설치
  - 리눅스에서는 파일 묶기와 압축이 분리되어 있음/ 여기서는 파일을 묶기만 함
  - apt install zip
  - zip -r aws-upload.zip ./*
  => aws-upload.zip 파일이 생겼음

- 리눅스에서 AWS cli 버전2 설치 https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/install-cliv2-linux.html    
  - unzip awscliv2.zip
  - sudo ./aws/install
  - aws --version
  =>aws 명령어 칠 수 있고, EC2에서 S3로 소스코드를 보내기 위해서 설치
  - aws configure
    AWS Access Key ID[none] : 내 key id 입력
    AWS Secret Access Key [None] : 입력 
    Default region name [None] : 입력
    Default output format [None] : json
  - aws s3 cp "aws-upload.zip" s3://aserang
  => s3 aserang 버킷에 aws-upload.zip 업로드 됐음

- AWS lambda
 - 함수생성
  - 함수이름 : image-resize
  - 런타임 : node.js 14.x  
  - 함수생성
  - ~에서 업로드 > 아마존 S3위치
   - https://aserang.s3.ap-northeast-2.amazonaws.com/aws-upload.zip
   - 저장
  => image-resize"Lambda 함수" 의 배포 패키지가 너무 커서 인라인 코드 편집을 활성화할 수 없습니다. 그러나 함수를 호출할 수 있습니다.
  - 구성 탭
   - 일반구성 > 메모리: 256MB, 제한시간 30초,
   - 트리거 > 트리거추가
    - S3 선택
    - 버킷 : aserang
    - 이벤트유형 : 모든 객체 생성 이벤트    
    - 접두사 : original/ => lambda가 실행되어 이미지 리사이징을 할 폴더
      original폴더에 파일이 들어가면 lambda실행 후 thumb폴더에 리사이징 이미지 들어감 
      접두사 안 붙이면 무한반복 됨
    - 재귀호출 클릭 후 추가
    
  - 런타임 설정
   - 핸들러 : index.handler => lambda 폴더>index.js 에서 exports.handler 한 이름을 적어야 함

- s3 thumb 폴더에 있는 리사이징된 이미지 가져 오기 
 - 로컬 back > routes > post
    router.post('/images', isLoggedIn, upload.array('image'), (req, res, next) => { // POST /post/images  
    res.json(req.files.map((v) => v.location.replace(/\/original\//,'/thumb'))); //filename=>location
 - 로컬 front 
  - component > ImageZoom
    <ImageWrapper key={v.src}>
        <img src={v.src.replace(/\/thumb\//,'/original/')} alt={v.src}/>
    </ImageWrapper>
  - component > PostForm
    {imagePaths.map((v, i) => (
     <div key={v} style={{ display: 'inline-block' }}>
       <img src={v.replace(/\/thumb\//,'/original/')} style={{ width: '200px' }} alt={v} />
   
 - git add, commit, push

 - EC2 front
  - git pull, npm run build
 
 - EC2 back 
  - git pull

  




//7-9 카카오톡 공유하기 & 강좌마무리


8장 보너스
//8-1 nginx+https 적용하기

//8-2 백엔드에 https 적용하기

//8-3 게시글수정하기

//8-4 빠르게 어드민 페이지 만들기 2021-04-20 수강
 -forest admin : https://www.forestadmin.com/ => 추천함
 -react-admin => 개발자가 다 만들어야 함.
 -coreui, adminlte
 
//8-5 팔로잉한 게시글만 가져오기












(예전 강의 기록들)
(예전6-2) next와 express 연결하기 => next 9버전부터 다이나믹라우팅의 제공으로 불필요해짐
- front에 server.js 만들고, express와 express 사용시 필요한 모듈들 설치
 - npm i express cookie-parser express-session morgan dotenv
 - npm i -D nodemon@2
- server.js 참조
 - 아래는 next에서 express로 next server 조절하는 방법 알려줌
   https://nextjs.org/docs/advanced-features/custom-server
- .env는 back에서 사용했던것과 동일하게 작성
 - .env의 cookie_secret가 다르면 back, front가 서로의 쿠키를 해독못하게 됨
- package.json에서 "scripts": { "dev": "nodemon"}
- nodemon.js에서 { "watch":[ "server.js", "nodemon.json" ], "exec": "node server.js", "ext":"js json" } 
- reducer>post>case ADD_COM~_SU~>
  const Comments = [...post.Comments, action.data.comment];

- 로그인 후에 새로고침하면, 로그인하기 전의 로그인창이 잠깐동안 화면에 보임
 - redux 개발창보면, INIT상태가 먼저고 이후 LOAD_MAIN_POST 등으로 넘어가는데
 INIT상태에서 user>me 가 null이고, post>mainPosts가 []빈 배열이라서 발생하는 현상
 -> 서버사이드랜더링(서버측에서 saga를 작동시키는 것)으로 해결가능



//6-7 미들웨어로 중복제거하기
- routes>middlewarejs 
 - 공통된 코드를 이쪽으로 옮겨적음
  - req.isAuthenticated() : passport에서 로그인했는지 확인해주는 함수
  - next(e) : 에러처리 미들웨어로 넘어감
  - next() : 다음미들웨어로 넘어감
- routes>postjs,userjs 에서 활용


(예전7-12) 개별 포스트 불러오기 => next 9버전부터 다이나믹라우팅의 제공으로 불필요해짐
- pages에 post.js 추가해서 페이지 만듬
- reducer에서 action 만듬
  LOAD_POST_REQUEST, LOAD_POST_SUCCESS, LOAD_POST_FAILURE
- saga>post watchLoadPost 추가
- route>post
- reducer>post 수정
- /post/1 이렇게 하려면 front의 expresss server도 수정해줘야 함

- 강의와 동일하게 코드를 수정했는데 오류남 이유 못찾겠음 - post/1이 없어서 오류났음

- 그런데 검색엔진이 내 웹페이지에 와서 뭐가 이미지인지 content인지 작성자인지 구별을 못함
  다 div로 감싸져 있기때문

- 검색엔진에 잘 노출시키려면 크게 2가지의 방법이 있음
 1) meta가 웹사이트에 대한 정보인데 meta 태그에 content를 적어주는 방법
 2) schema.org에 들어가서 html에 속성을 넣어주는 방법 => 따로 schema.org를 공부해야 함

(예전7-3) 리덕스 사가 액션 로깅하기 => getInitialProps부분 없어진듯
- hashtag useEffect 부분을 getInitialProps로 옮김
- 새로고침해도 데이터 못 불러옴

- user useEffect 부분을 getInitialProps로 옮김
- 새로고침하면 데이터 잘 불러옴

-hashtag page에서 action이 잘 dispatch 되었나 확인하기 위해서
 _appjs에서 아래코드 적어서 확인함
 ** 리덕스 사가 에러 찾아내는 방식 익혀둬야 함
 const middlewares = [sagaMiddleware, (store)=>(next)=>(action)=>{
  console.log('action confirm',action)
  next(action)
}];

-아래 에러메세지 나옴
action confirm {
  type: 'LOAD_USER_FAILURE',
  error: Error: Request failed with status code 401

- 강의에서는 아래 에러 코드가 나오고, 해석하면 요청할때 주소가 이상하다는 의미
  한글이 주소에 들어가서 생기는 문제일 가능성 있음
  {type:'@@redux-saga/CHANNEL_END'}
  {type: 'LOAD_HASHTAGS_POSTS_FAILURE',
  error:
   TypeError [ERR_UNESCAPED_CHARATERS] : Request path contains unescaped character
}

- saga>postjs에서 강의에서는 이렇게 수정하는데 나는 오류안남
function loadHashtagPostsAPI(tag) {
  return axios.get(`/hashtag/${encodeURIComponent(tag)}`);
- routes>hashtag에서 받을 때는 decodeURIComponent
 
- 나는 됐다 안됐다 반복됨, 이유 모르겠음
- 강의에서는 postman에서도 되는데 나는 안됨


(예전7-4) SSR에서 내 정보 처리하기 => getInitialProps부분 없어진듯
-로그인 후에 프로필 SSR
-page>profile useEffect 부분을 getInitialProps로 옮김
-SSR이 안됨 아래에 이유적힘
Profile.getInitialProps = async(context)=>{
  const state = context.store.getState();
  //이 직전에 appjs에서 LOAD_USERS_REQUEST 디스패치되는데 
  //LOAD_USERS_REQUEST 끝난후에 state.user.me이 생김
  //그런데 LOAD_USERS_SUCCESS는  LOAD_USER_POSTS_REQUEST 이후에 생김
  //따라서 에러남
  context.store.dispatch({//내 id와 연결된 팔로워 불러옴
    type: LOAD_FOLLOWERS_REQUEST,
    data: state.user.me && state.user.me.id,
  });
  context.store.dispatch({
    type: LOAD_FOLLOWINGS_REQUEST,
    data: state.user.me && state.user.me.id,
  });
  context.store.dispatch({
    type: LOAD_USER_POSTS_REQUEST,
    data: state.user.me && state.user.me.id,
  });
   //이 쯤에서 LOAD_USERS_SUCCESS 돼서 me가 생김
} 

- 해결하는 방법로직
 - LOAD_USERS_REQUEST 이후 LOAD_FOLLOWERS_REQUEST, 
   LOAD_FOLLOWINGS_REQUEST, LOAD_USER_POSTS_REQUEST가 디스패치가 되는데
   state.user.me는 LOAD_USERS_SUCCESS 후에 생기게 됨
   따라서 state.user.me는 null되는데, 이 null이 되는 속성을 사용하게됨
 - state.user.me가 null이면 me로 간주하게함
- 
 - saga>user에서 userId를 userId || 0으로 수정 
  function loadFollowersAPI(userId) {
    // 서버에 요청을 보내는 부분
    return axios.get(`/user/${userId || 0}/followers`, {
      withCredentials: true,
  function loadFollowingsAPI(userId) {
    // 서버에 요청을 보내는 부분
    return axios.get(`/user/${userId || 0}/followings`
 
 - saga>post에서
 function loadUserPostsAPI(id) {
  return axios.get(`/user/${id || 0}/posts`);

 - route>user에서
 router.get('/:id/posts', async (req, res, next) => {
  try {
    const posts = await db.Post.findAll({
      where: {
        //parseInt(req.params.id, 10)이 0이면 나로 인식하게 함
        //saga에서 userId를 0으로 주게 코딩했음
        //남의id면 그사람정보 가져오고, 0이면 내정보가져오고, 기본값은 0으로
        UserId: parseInt(req.params.id, 10) || (req.user && req.user.id) || 0,
        RetweetId: null, //리트윗한 게시글은 빼고 내가쓴 게시물만 불러옴
      },
router.get('/:id/followings', isLoggedIn, async (req, res, next) => { // /api/user/:id/followings
  try {    
    const user = await db.User.findOne({
      where: { id: parseInt(req.params.id, 10) || (req.user && req.user.id) || 0 },//내가 following하는 작성자
    } 
router.get('/:id/followers', isLoggedIn, async (req, res, next) => { // /api/user/:id/followers
 try {
   const user = await db.User.findOne({
     where: { id:  parseInt(req.params.id, 10) || (req.user && req.user.id) || 0  },//req.params.id 숫잔데~ 왜 paseInt해주지?
   });
- 이 해결방법은 꼼수? 비슷해서 경험이 쌓여야 작성할수 있다 함
- 제대로 불러와짐
- back 서버 통신 로그 : user/null로 나옴
GET /api/user/null/posts 200 63.381 ms - 4337
GET /api/user/0/followers 200 66.201 ms - 2
GET /api/user/0/followings 200 66.968 ms - 151


//7-5 회원가입 리다이렉션과 포스트 제거
- getInitialProps는 page에서만 씀
- 로그인했는데 회원가입 페이지로 가면 alert창'로그인했으니 메인페이지로 이동합니다' 뜨면서 메인페이지로 이동
 - 사용자의 정보를 가지로 있기 때문
 - 회원가입 페이지 자체를 안뜨게 코딩
 - pages>signup에서 if(me){ return null; } 추가
- SSR에서는 me를 먼저 불러오기 때문에 있는지 없는지를 확실하게 구분할 수 있음
  그러나 client 랜더링에서는 처음에는 me가 없고 후에 load user request
  를 하면 그때 받아오게 됨, 로그인을 했어도 잠깐동안 로그인이 풀리는 현상이 발생
- 브라우저에는 나라는 것을 판별하는 근거로 쿠키만을 사용함, 쿠키만 사용하므로
  me나 me.id를 가져올 방법이 없음, load users request로 me를 가져올 수 밖에 없음

- sequelize로 삭제하기
- postCard에서 ant popover 콤포넌트 추가
- saga> postjs 수정 
- route>postjs 수정
- reducer > postjs 수정, saga > post에서 user reducer에 put해줘야 함
  그래야지 짹짹갯수도 수정됨
  yield put({
    type: REMOVE_POST_OF_ME,
    data: result.data,
  });
-  reducer > user 수정

- 삭제 잘 됨


//7-13 react-helmet으로 head 태그 조작하기
- head에 있는 meta, title, script, style 4가지를 관리함
- npm i react-helmet
- 카독방에 웹사이트 링크 걸었을때, 나오는 화면들 중
  *og-open graph
  맨 윗단 - og:image
  제목 - og:title 
  내용 - og:description 
  주소 - og:url
- 각페이지마다 head에 내용이 달리 들어감
  ex) /post/9 => 9번 포스트의 제목, 내용, url emfdjrka
- 이렇게 되면 검색엔진이 해당 페이지의 정보를 알게 됨
- postman에서 보는 화면이 검색엔진이 보는 화면
- chrome 개발창에서 보면 meta내용들이 보이는데 postman에서 보면 보이지 않음
- SSR을 해줘야지 검색엔진이 읽을 수 있음

- pages>_document.js 만듬 / _document.js는 _app처럼 특수 js파일 임
 - _document.js : html의 역할, SSR하려면 직접 수정해야 함
 - 아직 함수형 문법을 지원하지 않아서 클래스형 리액트 문법을 써야 함

- 깃헙에 있는 내용 그대로 붙여 넣음
- 그런데 에러 남


//7-14 react-helmet SSR 
- getInitialProps에서 dispatch한 거는 chrome redux 개발창에서 뜨지 않음
 - 서버사이드 랜더링이라서 web을 거치지 않고 통신하기 때문이라고 설명하는 듯
- _appjs에서 HEAD와 helmet이 충돌이 있기 때문에, HEAD를 helmet으로 수정
- Head에 있는 내용을 Helmet 태그로 옮겨 적음
- 기본적으로는 _appjs에 있는 Helmet내용이 head태그에 들어가지만, 
  하위 콤포넌트에도 Helmet이 있으면 덮어쓰게 됨 
  Container를 불러와서 하위 콤포넌트 감쌈
  import {Container} from 'next/app'; 

- _document에서 context.renderPage(App)~ 적어줌
 _app에서도 하위 콤포넌트의 getInitialProps를 실행했듯이 =>  Component.getInitialProps(ctx); 
 _document에서도 하위 콤포넌트인 _app의 getInitialProps를 실행해야 함
- 이제 에러가 뜨지않고 랜더링이 됨, postman에서도 header 잘 보임

//8-5 최적화예제1
- 하나의 포스트에 하트(좋아요)를 눌렀는데, 전체 포스트가 리랜더링됨
- component/PostCard에서 function 코드 전체를 memo로 감쌈
- memo는 shellow 비교라서 props가 너무 복잡한 구조의 객체면, 리랜더링이
  되어야 되는 상황에서 안될 수도 있음
  => 해결이 안됐음

- comment 부분 최적화 => 따로 분리함
- containers > CommentForm.js 생성하고 PostCard에 있었던 comment부분 코드 옮겨적음
 - 수정사항이 많아서 여기에다가 코드 옮겨 적지는 않음

 -> 하트(좋아요)를 누르면, 전체포스트에서 외곽부분만 반짝거림

- CommentForm.js 생성하고 파일 작성하면서 useEffect를 불러오지 않아서 계속 오류가 났음
  그런데 useEffect를 불러오지 않은것을 eslint가 잡아내지 못함
  eslint-plugin-react-hooks 설치하고 문서에따라서 설정을 해도 못 잡아냄
  npm install eslint-plugin-react-hooks --save-dev

//8-6 최적화예제2
- 팔로우, 언팔로우 누르면 전체 랜더링됨
- containers>postcard>Card > extra 속성에 있는 코드를 따로 분리
- component>FollowButton.js 생성 후 코드 붙여 넣음
- 강의에서는 onFollow, onUnfollow 함수를 prop으로 넘겼는데, 나는 component에 작성함
=> 이렇게 해도 전체 랜더링 됨

- 어디서 문제가 발생했는지 찾아볼때는 console.log를 활용함, postcard에 아래코드 적어서 확인
  const postMemory = useRef(post);
  console.log('post',post);
  useEffect(()=>{ //어느 부분이 달라졌는지 비교할 수 있음
    console.log('post useEffect', postMemory.current ,post, postMemory.current === post )
  },[post])
 
  => 팔로우 버튼 누른 후 개발창 console창 보면, useEffect가 실행이 안되고 있음
  => post가 원인이 아님

- post를 me로 바꿔서 console.log 찍어봄
  const postMemory = useRef(me);
  console.log('me',me);
  useEffect(()=>{ //어느 부분이 달라졌는지 비교할 수 있음
    console.log('me useEffect', postMemory.current ,me, postMemory.current === me )
  },[me])

  => 팔로우 버튼 누른 후 개발창 console창 보면, useEffect가 실행이 됨
  => me와 useEffect이후의 me를 비교해보면 me.followings가 달라져 있는 것이 확인됨
  => me.followings는 postCard에서 쓰지도 않는데 저 녀석때문에 전체가 리랜더링 되고 있음

  => 그런데 아래처험 고치면 postCard에서 me 쓰이는 부분을 모두 id로 수정해줘야 함
     그래서 이 최적화는 pass 하기로 함

 ( postCard에서는 me.id만 사용하고 있으므로 아래와 같이 코드를 수정함
  const id = useSelector(state=>state.user.me && state.user.me.id);
  (이전코드) const { me } = useSelector(state=>state.user.me && state.user.me.id);
  
 - FollowButton에서 me를 바로 불러오도록 함
  const {me} = useSelector(state=>state.user); )


//8-7 최적화예제3
- 프로필페이지에서 더보기 버튼 눌렀을때, 그리고 포스트카드 좋아요 눌렀을때 전체 리랜더링 됨
- 팔로잉목록카드와 팔로워목록카드, 포스트카드가 서로서로에게 영향을 미침
- 따라서 셋 다 분리해야 함

- components > followList 생성
- 팔로잉목록카드와 팔로워목록카드는 공통되는 부분이 많아서 서로 다른 부분만 props로 넘김
- profile 페이지에서 아래와 같이 코드 수정
  <FollowList 
       header="팔로잉목록" 
       hasMore={hasMoreFollowing} 
       onClickMore={loadMoreFollowings} 
       data={followingList} 
       onClickStop={onUnfollow}
     />
   <FollowList 
    header="팔로워목록" 
    hasMore={hasMoreFollowing} 
    onClickMore={loadMoreFollowers} 
    data={followerList} 
    onClickStop={onRemoveFollower}
  />


=> 강사님 코드에서는 테두만 리랜더링 되는데, 내 코드에서는 전체 리랜더링 됨
=> 그런데 강사님 컴퓨터에서도 전체 리랜더링 되는 것처럼 보이긴 함
=> 포스트카드 좋아요 버튼 누르면, 팔로워/팔로잉목록카드 테두리만 리랜더링 됨

- 최적화Tip
 - 전체 리랜더링 시키는 것은 콤포넌트로 분리
 - memo
 - memo했는데도 안되면, useSelector, useState에서 객체가 있는지 확인하고
   (객체가 대부분 원인 임) 객체가 원인이면 객체에서 값만 가져오도록 수정함
 

- 생활코딩 github 2020.04.21
 - dropbox : 한 회사가 만든 app => client와 server가 하나뿐임
  - dropbox client : 수정파일 있을때, 업로드 함
  - dropbox.com server : 수정파일 저장
 - git : open source => 여러 client와 server 존재
  - git client : 
  - git server(원격저장소) : github

 - 저장소 생성
 
 - git 
  - vscode terminal에서 git clone https://github.com/jihwoopark/lifecoding.git
  - https://github.com/jihwoopark/lifecoding.git 주소에 연결된 
   github 저장소 안의 파일들을 내 컴퓨터로 다운로드 함
  - 다운 받은 파일을 수정하고 git diff 명령어 치면 어느 파일에서 수정햇는지 보여줌

  - git log : 작업한 history 보여 줌
  - git status : 현재 상태 보여줌 ex)내가 어디를 수정했는지도 보여줌
  - git add file3.text : 수정한 파일을 추가
  - git commit -m "version5" : 커밋하는 이름은 version5로 하라
  - git push : 내 컴퓨터에서 수정한 내용을 github에 반영 (upload, 동기화)
  

- 패스트캠퍼스 프론트엔드react / git & github 2020.

- jquery 강의
 - jquery 잘 정리된 사이트
 - https://oscarotero.com/jquery/
   
